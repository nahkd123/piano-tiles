/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/midi-player-js/build/index.browser.js":
/*!************************************************************!*\
  !*** ./node_modules/midi-player-js/build/index.browser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * Constants used in player.\n */\nvar Constants = {\n  VERSION: '2.0.16',\n  NOTES: [],\n  HEADER_CHUNK_LENGTH: 14,\n  CIRCLE_OF_FOURTHS: ['C', 'F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb', 'Fb', 'Bbb', 'Ebb', 'Abb'],\n  CIRCLE_OF_FIFTHS: ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#']\n}; // Builds notes object for reference against binary values.\n\nvar allNotes = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']];\nvar counter = 0; // All available octaves.\n\nvar _loop = function _loop(i) {\n  allNotes.forEach(function (noteGroup) {\n    noteGroup.forEach(function (note) {\n      return Constants.NOTES[counter] = note + i;\n    });\n    counter++;\n  });\n};\n\nfor (var i = -1; i <= 9; i++) {\n  _loop(i);\n}\n\n/**\n * Contains misc static utility methods.\n */\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {\n    _classCallCheck(this, Utils);\n  }\n\n  _createClass(Utils, null, [{\n    key: \"byteToHex\",\n    value:\n    /**\n     * Converts a single byte to a hex string.\n     * @param {number} byte\n     * @return {string}\n     */\n    function byteToHex(_byte) {\n      // Ensure hex string always has two chars\n      return ('0' + _byte.toString(16)).slice(-2);\n    }\n    /**\n     * Converts an array of bytes to a hex string.\n     * @param {array} byteArray\n     * @return {string}\n     */\n\n  }, {\n    key: \"bytesToHex\",\n    value: function bytesToHex(byteArray) {\n      var hex = [];\n      byteArray.forEach(function (_byte2) {\n        return hex.push(Utils.byteToHex(_byte2));\n      });\n      return hex.join('');\n    }\n    /**\n     * Converts a hex string to a number.\n     * @param {string} hexString\n     * @return {number}\n     */\n\n  }, {\n    key: \"hexToNumber\",\n    value: function hexToNumber(hexString) {\n      return parseInt(hexString, 16);\n    }\n    /**\n     * Converts an array of bytes to a number.\n     * @param {array} byteArray\n     * @return {number}\n     */\n\n  }, {\n    key: \"bytesToNumber\",\n    value: function bytesToNumber(byteArray) {\n      return Utils.hexToNumber(Utils.bytesToHex(byteArray));\n    }\n    /**\n     * Converts an array of bytes to letters.\n     * @param {array} byteArray\n     * @return {string}\n     */\n\n  }, {\n    key: \"bytesToLetters\",\n    value: function bytesToLetters(byteArray) {\n      var letters = [];\n      byteArray.forEach(function (_byte3) {\n        return letters.push(String.fromCharCode(_byte3));\n      });\n      return letters.join('');\n    }\n    /**\n     * Converts a decimal to it's binary representation.\n     * @param {number} dec\n     * @return {string}\n     */\n\n  }, {\n    key: \"decToBinary\",\n    value: function decToBinary(dec) {\n      return (dec >>> 0).toString(2);\n    }\n    /**\n     * Determines the length in bytes of a variable length quaantity.  The first byte in given range is assumed to be beginning of var length quantity.\n     * @param {array} byteArray\n     * @return {number}\n     */\n\n  }, {\n    key: \"getVarIntLength\",\n    value: function getVarIntLength(byteArray) {\n      // Get byte count of delta VLV\n      // http://www.ccarh.org/courses/253/handout/vlv/\n      // If byte is greater or equal to 80h (128 decimal) then the next byte\n      // is also part of the VLV,\n      // else byte is the last byte in a VLV.\n      var currentByte = byteArray[0];\n      var byteCount = 1;\n\n      while (currentByte >= 128) {\n        currentByte = byteArray[byteCount];\n        byteCount++;\n      }\n\n      return byteCount;\n    }\n    /**\n     * Reads a variable length value.\n     * @param {array} byteArray\n     * @return {number}\n     */\n\n  }, {\n    key: \"readVarInt\",\n    value: function readVarInt(byteArray) {\n      var result = 0;\n      byteArray.forEach(function (number) {\n        var b = number;\n\n        if (b & 0x80) {\n          result += b & 0x7f;\n          result <<= 7;\n        } else {\n          /* b is the last byte */\n          result += b;\n        }\n      });\n      return result;\n    }\n    /**\n     * Decodes base-64 encoded string\n     * @param {string} string\n     * @return {string}\n     */\n\n  }, {\n    key: \"atob\",\n    value: function (_atob) {\n      function atob(_x) {\n        return _atob.apply(this, arguments);\n      }\n\n      atob.toString = function () {\n        return _atob.toString();\n      };\n\n      return atob;\n    }(function (string) {\n      if (typeof atob === 'function') return atob(string);\n      return Buffer.from(string, 'base64').toString('binary');\n    })\n  }]);\n\n  return Utils;\n}();\n\n/**\n * Class representing a track.  Contains methods for parsing events and keeping track of pointer.\n */\n\nvar Track = /*#__PURE__*/function () {\n  function Track(index, data) {\n    _classCallCheck(this, Track);\n\n    this.enabled = true;\n    this.eventIndex = 0;\n    this.pointer = 0;\n    this.lastTick = 0;\n    this.lastStatus = null;\n    this.index = index;\n    this.data = data;\n    this.delta = 0;\n    this.runningDelta = 0;\n    this.events = []; // Ensure last 3 bytes of track are End of Track event\n\n    var lastThreeBytes = this.data.subarray(this.data.length - 3, this.data.length);\n\n    if (!(lastThreeBytes[0] === 0xff && lastThreeBytes[1] === 0x2f && lastThreeBytes[2] === 0x00)) {\n      throw 'Invalid MIDI file; Last three bytes of track ' + this.index + 'must be FF 2F 00 to mark end of track';\n    }\n  }\n  /**\n   * Resets all stateful track informaion used during playback.\n   * @return {Track}\n   */\n\n\n  _createClass(Track, [{\n    key: \"reset\",\n    value: function reset() {\n      this.enabled = true;\n      this.eventIndex = 0;\n      this.pointer = 0;\n      this.lastTick = 0;\n      this.lastStatus = null;\n      this.delta = 0;\n      this.runningDelta = 0;\n      return this;\n    }\n    /**\n     * Sets this track to be enabled during playback.\n     * @return {Track}\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this.enabled = true;\n      return this;\n    }\n    /**\n     * Sets this track to be disabled during playback.\n     * @return {Track}\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n    /**\n     * Sets the track event index to the nearest event to the given tick.\n     * @param {number} tick\n     * @return {Track}\n     */\n\n  }, {\n    key: \"setEventIndexByTick\",\n    value: function setEventIndexByTick(tick) {\n      tick = tick || 0;\n\n      for (var i in this.events) {\n        if (this.events[i].tick >= tick) {\n          this.eventIndex = i;\n          return this;\n        }\n      }\n    }\n    /**\n     * Gets byte located at pointer position.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getCurrentByte\",\n    value: function getCurrentByte() {\n      return this.data[this.pointer];\n    }\n    /**\n     * Gets count of delta bytes and current pointer position.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getDeltaByteCount\",\n    value: function getDeltaByteCount() {\n      return Utils.getVarIntLength(this.data.subarray(this.pointer));\n    }\n    /**\n     * Get delta value at current pointer position.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getDelta\",\n    value: function getDelta() {\n      return Utils.readVarInt(this.data.subarray(this.pointer, this.pointer + this.getDeltaByteCount()));\n    }\n    /**\n     * Handles event within a given track starting at specified index\n     * @param {number} currentTick\n     * @param {boolean} dryRun - If true events will be parsed and returned regardless of time.\n     */\n\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(currentTick, dryRun) {\n      dryRun = dryRun || false;\n\n      if (dryRun) {\n        var elapsedTicks = currentTick - this.lastTick;\n        var delta = this.getDelta();\n        var eventReady = elapsedTicks >= delta;\n\n        if (this.pointer < this.data.length && (dryRun || eventReady)) {\n          var _event = this.parseEvent();\n\n          if (this.enabled) return _event; // Recursively call this function for each event ahead that has 0 delta time?\n        }\n      } else {\n        // Let's actually play the MIDI from the generated JSON events created by the dry run.\n        if (this.events[this.eventIndex] && this.events[this.eventIndex].tick <= currentTick) {\n          this.eventIndex++;\n          if (this.enabled) return this.events[this.eventIndex - 1];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Get string data from event.\n     * @param {number} eventStartIndex\n     * @return {string}\n     */\n\n  }, {\n    key: \"getStringData\",\n    value: function getStringData(eventStartIndex) {\n      var varIntLength = Utils.getVarIntLength(this.data.subarray(eventStartIndex + 2));\n      var varIntValue = Utils.readVarInt(this.data.subarray(eventStartIndex + 2, eventStartIndex + 2 + varIntLength));\n      var letters = Utils.bytesToLetters(this.data.subarray(eventStartIndex + 2 + varIntLength, eventStartIndex + 2 + varIntLength + varIntValue));\n      return letters;\n    }\n    /**\n     * Parses event into JSON and advances pointer for the track\n     * @return {object}\n     */\n\n  }, {\n    key: \"parseEvent\",\n    value: function parseEvent() {\n      var eventStartIndex = this.pointer + this.getDeltaByteCount();\n      var eventJson = {};\n      var deltaByteCount = this.getDeltaByteCount();\n      eventJson.track = this.index + 1;\n      eventJson.delta = this.getDelta();\n      this.lastTick = this.lastTick + eventJson.delta;\n      this.runningDelta += eventJson.delta;\n      eventJson.tick = this.runningDelta;\n      eventJson.byteIndex = this.pointer; //eventJson.raw = event;\n\n      if (this.data[eventStartIndex] == 0xff) {\n        // Meta Event\n        // If this is a meta event we should emit the data and immediately move to the next event\n        // otherwise if we let it run through the next cycle a slight delay will accumulate if multiple tracks\n        // are being played simultaneously\n        switch (this.data[eventStartIndex + 1]) {\n          case 0x00:\n            // Sequence Number\n            eventJson.name = 'Sequence Number';\n            break;\n\n          case 0x01:\n            // Text Event\n            eventJson.name = 'Text Event';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x02:\n            // Copyright Notice\n            eventJson.name = 'Copyright Notice';\n            break;\n\n          case 0x03:\n            // Sequence/Track Name\n            eventJson.name = 'Sequence/Track Name';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x04:\n            // Instrument Name\n            eventJson.name = 'Instrument Name';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x05:\n            // Lyric\n            eventJson.name = 'Lyric';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x06:\n            // Marker\n            eventJson.name = 'Marker';\n            break;\n\n          case 0x07:\n            // Cue Point\n            eventJson.name = 'Cue Point';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x09:\n            // Device Name\n            eventJson.name = 'Device Name';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x20:\n            // MIDI Channel Prefix\n            eventJson.name = 'MIDI Channel Prefix';\n            break;\n\n          case 0x21:\n            // MIDI Port\n            eventJson.name = 'MIDI Port';\n            eventJson.data = Utils.bytesToNumber([this.data[eventStartIndex + 3]]);\n            break;\n\n          case 0x2F:\n            // End of Track\n            eventJson.name = 'End of Track';\n            break;\n\n          case 0x51:\n            // Set Tempo\n            eventJson.name = 'Set Tempo';\n            eventJson.data = Math.round(60000000 / Utils.bytesToNumber(this.data.subarray(eventStartIndex + 3, eventStartIndex + 6)));\n            this.tempo = eventJson.data;\n            break;\n\n          case 0x54:\n            // SMTPE Offset\n            eventJson.name = 'SMTPE Offset';\n            break;\n\n          case 0x58:\n            // Time Signature\n            // FF 58 04 nn dd cc bb\n            eventJson.name = 'Time Signature';\n            eventJson.data = this.data.subarray(eventStartIndex + 3, eventStartIndex + 7);\n            eventJson.timeSignature = \"\" + eventJson.data[0] + \"/\" + Math.pow(2, eventJson.data[1]);\n            break;\n\n          case 0x59:\n            // Key Signature\n            // FF 59 02 sf mi\n            eventJson.name = 'Key Signature';\n            eventJson.data = this.data.subarray(eventStartIndex + 3, eventStartIndex + 5);\n\n            if (eventJson.data[0] >= 0) {\n              eventJson.keySignature = Constants.CIRCLE_OF_FIFTHS[eventJson.data[0]];\n            } else if (eventJson.data[0] < 0) {\n              eventJson.keySignature = Constants.CIRCLE_OF_FOURTHS[Math.abs(eventJson.data[0])];\n            }\n\n            if (eventJson.data[1] == 0) {\n              eventJson.keySignature += \" Major\";\n            } else if (eventJson.data[1] == 1) {\n              eventJson.keySignature += \" Minor\";\n            }\n\n            break;\n\n          case 0x7F:\n            // Sequencer-Specific Meta-event\n            eventJson.name = 'Sequencer-Specific Meta-event';\n            break;\n\n          default:\n            eventJson.name = 'Unknown: ' + this.data[eventStartIndex + 1].toString(16);\n            break;\n        }\n\n        var varIntLength = Utils.getVarIntLength(this.data.subarray(eventStartIndex + 2));\n        var length = Utils.readVarInt(this.data.subarray(eventStartIndex + 2, eventStartIndex + 2 + varIntLength)); //console.log(eventJson);\n\n        this.pointer += deltaByteCount + 3 + length; //console.log(eventJson);\n      } else if (this.data[eventStartIndex] === 0xf0) {\n        // Sysex\n        eventJson.name = 'Sysex';\n        var varQuantityByteLength = Utils.getVarIntLength(this.data.subarray(eventStartIndex + 1));\n        var varQuantityByteValue = Utils.readVarInt(this.data.subarray(eventStartIndex + 1, eventStartIndex + 1 + varQuantityByteLength));\n        eventJson.data = this.data.subarray(eventStartIndex + 1 + varQuantityByteLength, eventStartIndex + 1 + varQuantityByteLength + varQuantityByteValue);\n        this.pointer += deltaByteCount + 1 + varQuantityByteLength + varQuantityByteValue;\n      } else if (this.data[eventStartIndex] === 0xf7) {\n        // Sysex (escape)\n        // http://www.somascape.org/midi/tech/mfile.html#sysex\n        eventJson.name = 'Sysex (escape)';\n\n        var _varQuantityByteLength = Utils.getVarIntLength(this.data.subarray(eventStartIndex + 1));\n\n        var _varQuantityByteValue = Utils.readVarInt(this.data.subarray(eventStartIndex + 1, eventStartIndex + 1 + _varQuantityByteLength));\n\n        eventJson.data = this.data.subarray(eventStartIndex + 1 + _varQuantityByteLength, eventStartIndex + 1 + _varQuantityByteLength + _varQuantityByteValue);\n        this.pointer += deltaByteCount + 1 + _varQuantityByteLength + _varQuantityByteValue;\n      } else {\n        // Voice event\n        if (this.data[eventStartIndex] < 0x80) {\n          // Running status\n          eventJson.running = true;\n          eventJson.noteNumber = this.data[eventStartIndex];\n          eventJson.noteName = Constants.NOTES[this.data[eventStartIndex]];\n          eventJson.velocity = this.data[eventStartIndex + 1];\n\n          if (this.lastStatus <= 0x8f) {\n            eventJson.name = 'Note off';\n            eventJson.channel = this.lastStatus - 0x80 + 1;\n            this.pointer += deltaByteCount + 2;\n          } else if (this.lastStatus <= 0x9f) {\n            eventJson.name = 'Note on';\n            eventJson.channel = this.lastStatus - 0x90 + 1;\n            this.pointer += deltaByteCount + 2;\n          } else if (this.lastStatus <= 0xaf) {\n            // Polyphonic Key Pressure\n            eventJson.name = 'Polyphonic Key Pressure';\n            eventJson.channel = this.lastStatus - 0xa0 + 1;\n            eventJson.note = Constants.NOTES[this.data[eventStartIndex + 1]];\n            eventJson.pressure = event[1];\n            this.pointer += deltaByteCount + 2;\n          } else if (this.lastStatus <= 0xbf) {\n            // Controller Change\n            eventJson.name = 'Controller Change';\n            eventJson.channel = this.lastStatus - 0xb0 + 1;\n            eventJson.number = this.data[eventStartIndex + 1];\n            eventJson.value = this.data[eventStartIndex + 2];\n            this.pointer += deltaByteCount + 2;\n          } else if (this.lastStatus <= 0xcf) {\n            // Program Change\n            eventJson.name = 'Program Change';\n            eventJson.channel = this.lastStatus - 0xc0 + 1;\n            eventJson.value = this.data[eventStartIndex + 1];\n            this.pointer += deltaByteCount + 1;\n          } else if (this.lastStatus <= 0xdf) {\n            // Channel Key Pressure\n            eventJson.name = 'Channel Key Pressure';\n            eventJson.channel = this.lastStatus - 0xd0 + 1;\n            this.pointer += deltaByteCount + 1;\n          } else if (this.lastStatus <= 0xef) {\n            // Pitch Bend\n            eventJson.name = 'Pitch Bend';\n            eventJson.channel = this.lastStatus - 0xe0 + 1;\n            eventJson.value = this.data[eventStartIndex + 2];\n            this.pointer += deltaByteCount + 2;\n          } else {\n            throw \"Unknown event (running): \".concat(this.lastStatus);\n          }\n        } else {\n          this.lastStatus = this.data[eventStartIndex];\n\n          if (this.data[eventStartIndex] <= 0x8f) {\n            // Note off\n            eventJson.name = 'Note off';\n            eventJson.channel = this.lastStatus - 0x80 + 1;\n            eventJson.noteNumber = this.data[eventStartIndex + 1];\n            eventJson.noteName = Constants.NOTES[this.data[eventStartIndex + 1]];\n            eventJson.velocity = Math.round(this.data[eventStartIndex + 2] / 127 * 100);\n            this.pointer += deltaByteCount + 3;\n          } else if (this.data[eventStartIndex] <= 0x9f) {\n            // Note on\n            eventJson.name = 'Note on';\n            eventJson.channel = this.lastStatus - 0x90 + 1;\n            eventJson.noteNumber = this.data[eventStartIndex + 1];\n            eventJson.noteName = Constants.NOTES[this.data[eventStartIndex + 1]];\n            eventJson.velocity = Math.round(this.data[eventStartIndex + 2] / 127 * 100);\n            this.pointer += deltaByteCount + 3;\n          } else if (this.data[eventStartIndex] <= 0xaf) {\n            // Polyphonic Key Pressure\n            eventJson.name = 'Polyphonic Key Pressure';\n            eventJson.channel = this.lastStatus - 0xa0 + 1;\n            eventJson.note = Constants.NOTES[this.data[eventStartIndex + 1]];\n            eventJson.pressure = event[2];\n            this.pointer += deltaByteCount + 3;\n          } else if (this.data[eventStartIndex] <= 0xbf) {\n            // Controller Change\n            eventJson.name = 'Controller Change';\n            eventJson.channel = this.lastStatus - 0xb0 + 1;\n            eventJson.number = this.data[eventStartIndex + 1];\n            eventJson.value = this.data[eventStartIndex + 2];\n            this.pointer += deltaByteCount + 3;\n          } else if (this.data[eventStartIndex] <= 0xcf) {\n            // Program Change\n            eventJson.name = 'Program Change';\n            eventJson.channel = this.lastStatus - 0xc0 + 1;\n            eventJson.value = this.data[eventStartIndex + 1];\n            this.pointer += deltaByteCount + 2;\n          } else if (this.data[eventStartIndex] <= 0xdf) {\n            // Channel Key Pressure\n            eventJson.name = 'Channel Key Pressure';\n            eventJson.channel = this.lastStatus - 0xd0 + 1;\n            this.pointer += deltaByteCount + 2;\n          } else if (this.data[eventStartIndex] <= 0xef) {\n            // Pitch Bend\n            eventJson.name = 'Pitch Bend';\n            eventJson.channel = this.lastStatus - 0xe0 + 1;\n            this.pointer += deltaByteCount + 3;\n          } else {\n            throw \"Unknown event: \".concat(this.data[eventStartIndex]); //eventJson.name = `Unknown.  Pointer: ${this.pointer.toString()}, ${eventStartIndex.toString()}, ${this.data[eventStartIndex]}, ${this.data.length}`;\n          }\n        }\n      }\n\n      this.delta += eventJson.delta;\n      this.events.push(eventJson);\n      return eventJson;\n    }\n    /**\n     * Returns true if pointer has reached the end of the track.\n     * @param {boolean}\n     */\n\n  }, {\n    key: \"endOfTrack\",\n    value: function endOfTrack() {\n      if (this.data[this.pointer + 1] == 0xff && this.data[this.pointer + 2] == 0x2f && this.data[this.pointer + 3] == 0x00) {\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return Track;\n}();\n\nif (!Uint8Array.prototype.forEach) {\n  Object.defineProperty(Uint8Array.prototype, 'forEach', {\n    value: Array.prototype.forEach\n  });\n}\n/**\n * Main player class.  Contains methods to load files, start, stop.\n * @param {function} - Callback to fire for each MIDI event.  Can also be added with on('midiEvent', fn)\n * @param {array} - Array buffer of MIDI file (optional).\n */\n\n\nvar Player = /*#__PURE__*/function () {\n  function Player(eventHandler, buffer) {\n    _classCallCheck(this, Player);\n\n    this.sampleRate = 5; // milliseconds\n\n    this.startTime = 0;\n    this.buffer = buffer || null;\n    this.midiChunksByteLength = null;\n    this.division;\n    this.format;\n    this.setIntervalId = false;\n    this.tracks = [];\n    this.instruments = [];\n    this.defaultTempo = 120;\n    this.tempo = null;\n    this.startTick = 0;\n    this.tick = 0;\n    this.lastTick = null;\n    this.inLoop = false;\n    this.totalTicks = 0;\n    this.events = [];\n    this.totalEvents = 0;\n    this.eventListeners = {};\n    if (typeof eventHandler === 'function') this.on('midiEvent', eventHandler);\n  }\n  /**\n   * Load a file into the player (Node.js only).\n   * @param {string} path - Path of file.\n   * @return {Player}\n   */\n\n\n  _createClass(Player, [{\n    key: \"loadFile\",\n    value: function loadFile(path) {\n      {\n        throw 'loadFile is only supported on Node.js';\n      }\n    }\n    /**\n     * Load an array buffer into the player.\n     * @param {array} arrayBuffer - Array buffer of file to be loaded.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"loadArrayBuffer\",\n    value: function loadArrayBuffer(arrayBuffer) {\n      this.buffer = new Uint8Array(arrayBuffer);\n      return this.fileLoaded();\n    }\n    /**\n     * Load a data URI into the player.\n     * @param {string} dataUri - Data URI to be loaded.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"loadDataUri\",\n    value: function loadDataUri(dataUri) {\n      // convert base64 to raw binary data held in a string.\n      // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this\n      var byteString = Utils.atob(dataUri.split(',')[1]); // write the bytes of the string to an ArrayBuffer\n\n      var ia = new Uint8Array(byteString.length);\n\n      for (var i = 0; i < byteString.length; i++) {\n        ia[i] = byteString.charCodeAt(i);\n      }\n\n      this.buffer = ia;\n      return this.fileLoaded();\n    }\n    /**\n     * Get filesize of loaded file in number of bytes.\n     * @return {number} - The filesize.\n     */\n\n  }, {\n    key: \"getFilesize\",\n    value: function getFilesize() {\n      return this.buffer ? this.buffer.length : 0;\n    }\n    /**\n     * Sets default tempo, parses file for necessary information, and does a dry run to calculate total length.\n     * Populates this.events & this.totalTicks.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"fileLoaded\",\n    value: function fileLoaded() {\n      if (!this.validate()) throw 'Invalid MIDI file; should start with MThd';\n      return this.setTempo(this.defaultTempo).getDivision().getFormat().getTracks().dryRun();\n    }\n    /**\n     * Validates file using simple means - first four bytes should == MThd.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      //console.log((this.buffer.subarray(0, 15)));\n      return Utils.bytesToLetters(this.buffer.subarray(0, 4)) === 'MThd';\n    }\n    /**\n     * Gets MIDI file format for loaded file.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"getFormat\",\n    value: function getFormat() {\n      /*\n      MIDI files come in 3 variations:\n      Format 0 which contain a single track\n      Format 1 which contain one or more simultaneous tracks\n      (ie all tracks are to be played simultaneously).\n      Format 2 which contain one or more independant tracks\n      (ie each track is to be played independantly of the others).\n      return Utils.bytesToNumber(this.buffer.subarray(8, 10));\n      */\n      this.format = Utils.bytesToNumber(this.buffer.subarray(8, 10));\n      return this;\n    }\n    /**\n     * Parses out tracks, places them in this.tracks and initializes this.pointers\n     * @return {Player}\n     */\n\n  }, {\n    key: \"getTracks\",\n    value: function getTracks() {\n      this.tracks = [];\n      var trackOffset = 0;\n\n      while (trackOffset < this.buffer.length) {\n        if (Utils.bytesToLetters(this.buffer.subarray(trackOffset, trackOffset + 4)) == 'MTrk') {\n          var trackLength = Utils.bytesToNumber(this.buffer.subarray(trackOffset + 4, trackOffset + 8));\n          this.tracks.push(new Track(this.tracks.length, this.buffer.subarray(trackOffset + 8, trackOffset + 8 + trackLength)));\n        }\n\n        trackOffset += Utils.bytesToNumber(this.buffer.subarray(trackOffset + 4, trackOffset + 8)) + 8;\n      } // Get sum of all MIDI chunks here while we're at it\n\n\n      var trackChunksByteLength = 0;\n      this.tracks.forEach(function (track) {\n        trackChunksByteLength += 8 + track.data.length;\n      });\n      this.midiChunksByteLength = Constants.HEADER_CHUNK_LENGTH + trackChunksByteLength;\n      return this;\n    }\n    /**\n     * Enables a track for playing.\n     * @param {number} trackNumber - Track number\n     * @return {Player}\n     */\n\n  }, {\n    key: \"enableTrack\",\n    value: function enableTrack(trackNumber) {\n      this.tracks[trackNumber - 1].enable();\n      return this;\n    }\n    /**\n     * Disables a track for playing.\n     * @param {number} - Track number\n     * @return {Player}\n     */\n\n  }, {\n    key: \"disableTrack\",\n    value: function disableTrack(trackNumber) {\n      this.tracks[trackNumber - 1].disable();\n      return this;\n    }\n    /**\n     * Gets quarter note division of loaded MIDI file.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"getDivision\",\n    value: function getDivision() {\n      this.division = Utils.bytesToNumber(this.buffer.subarray(12, Constants.HEADER_CHUNK_LENGTH));\n      return this;\n    }\n    /**\n     * The main play loop.\n     * @param {boolean} - Indicates whether or not this is being called simply for parsing purposes.  Disregards timing if so.\n     * @return {undefined}\n     */\n\n  }, {\n    key: \"playLoop\",\n    value: function playLoop(dryRun) {\n      if (!this.inLoop) {\n        this.inLoop = true;\n        this.tick = this.getCurrentTick();\n        this.tracks.forEach(function (track, index) {\n          // Handle next event\n          if (!dryRun && this.endOfFile()) {\n            //console.log('end of file')\n            this.triggerPlayerEvent('endOfFile');\n            this.stop();\n          } else {\n            var event = track.handleEvent(this.tick, dryRun);\n\n            if (dryRun && event) {\n              if (event.hasOwnProperty('name') && event.name === 'Set Tempo') {\n                // Grab tempo if available.\n                this.defaultTempo = event.data;\n                this.setTempo(event.data);\n              }\n\n              if (event.hasOwnProperty('name') && event.name === 'Program Change') {\n                if (!this.instruments.includes(event.value)) {\n                  this.instruments.push(event.value);\n                }\n              }\n            } else if (event) {\n              if (event.hasOwnProperty('name') && event.name === 'Set Tempo') {\n                // Grab tempo if available.\n                this.setTempo(event.data);\n\n                if (this.isPlaying()) {\n                  this.pause().play();\n                }\n              }\n\n              this.emitEvent(event);\n            }\n          }\n        }, this);\n        if (!dryRun) this.triggerPlayerEvent('playing', {\n          tick: this.tick\n        });\n        this.inLoop = false;\n      }\n    }\n    /**\n     * Setter for tempo.\n     * @param {number} - Tempo in bpm (defaults to 120)\n     */\n\n  }, {\n    key: \"setTempo\",\n    value: function setTempo(tempo) {\n      this.tempo = tempo;\n      return this;\n    }\n    /**\n     * Setter for startTime.\n     * @param {number} - UTC timestamp\n     * @return {Player}\n     */\n\n  }, {\n    key: \"setStartTime\",\n    value: function setStartTime(startTime) {\n      this.startTime = startTime;\n      return this;\n    }\n    /**\n     * Start playing loaded MIDI file if not already playing.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this.isPlaying()) throw 'Already playing...'; // Initialize\n\n      if (!this.startTime) this.startTime = new Date().getTime(); // Start play loop\n      //window.requestAnimationFrame(this.playLoop.bind(this));\n\n      this.setIntervalId = setInterval(this.playLoop.bind(this), this.sampleRate); //this.setIntervalId = this.loop();\n\n      return this;\n    }\n  }, {\n    key: \"loop\",\n    value: function loop() {\n      setTimeout(function () {\n        // Do Something Here\n        this.playLoop(); // Then recall the parent function to\n        // create a recursive loop.\n\n        this.loop();\n      }.bind(this), this.sampleRate);\n    }\n    /**\n     * Pauses playback if playing.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      clearInterval(this.setIntervalId);\n      this.setIntervalId = false;\n      this.startTick = this.tick;\n      this.startTime = 0;\n      return this;\n    }\n    /**\n     * Stops playback if playing.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      clearInterval(this.setIntervalId);\n      this.setIntervalId = false;\n      this.startTick = 0;\n      this.startTime = 0;\n      this.resetTracks();\n      return this;\n    }\n    /**\n     * Skips player pointer to specified tick.\n     * @param {number} - Tick to skip to.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"skipToTick\",\n    value: function skipToTick(tick) {\n      this.stop();\n      this.startTick = tick; // Need to set track event indexes to the nearest possible event to the specified tick.\n\n      this.tracks.forEach(function (track) {\n        track.setEventIndexByTick(tick);\n      });\n      return this;\n    }\n    /**\n     * Skips player pointer to specified percentage.\n     * @param {number} - Percent value in integer format.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"skipToPercent\",\n    value: function skipToPercent(percent) {\n      if (percent < 0 || percent > 100) throw \"Percent must be number between 1 and 100.\";\n      this.skipToTick(Math.round(percent / 100 * this.totalTicks));\n      return this;\n    }\n    /**\n     * Skips player pointer to specified seconds.\n     * @param {number} - Seconds to skip to.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"skipToSeconds\",\n    value: function skipToSeconds(seconds) {\n      var songTime = this.getSongTime();\n      if (seconds < 0 || seconds > songTime) throw seconds + \" seconds not within song time of \" + songTime;\n      this.skipToPercent(seconds / songTime * 100);\n      return this;\n    }\n    /**\n     * Checks if player is playing\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isPlaying\",\n    value: function isPlaying() {\n      return this.setIntervalId > 0 || _typeof(this.setIntervalId) === 'object';\n    }\n    /**\n     * Plays the loaded MIDI file without regard for timing and saves events in this.events.  Essentially used as a parser.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"dryRun\",\n    value: function dryRun() {\n      // Reset tracks first\n      this.resetTracks();\n\n      while (!this.endOfFile()) {\n        this.playLoop(true); //console.log(this.bytesProcessed(), this.midiChunksByteLength);\n      }\n\n      this.events = this.getEvents();\n      this.totalEvents = this.getTotalEvents();\n      this.totalTicks = this.getTotalTicks();\n      this.startTick = 0;\n      this.startTime = 0; // Leave tracks in pristine condish\n\n      this.resetTracks(); //console.log('Song time: ' + this.getSongTime() + ' seconds / ' + this.totalTicks + ' ticks.');\n\n      this.triggerPlayerEvent('fileLoaded', this);\n      return this;\n    }\n    /**\n     * Resets play pointers for all tracks.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"resetTracks\",\n    value: function resetTracks() {\n      this.tracks.forEach(function (track) {\n        return track.reset();\n      });\n      return this;\n    }\n    /**\n     * Gets an array of events grouped by track.\n     * @return {array}\n     */\n\n  }, {\n    key: \"getEvents\",\n    value: function getEvents() {\n      return this.tracks.map(function (track) {\n        return track.events;\n      });\n    }\n    /**\n     * Gets total number of ticks in the loaded MIDI file.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getTotalTicks\",\n    value: function getTotalTicks() {\n      return Math.max.apply(null, this.tracks.map(function (track) {\n        return track.delta;\n      }));\n    }\n    /**\n     * Gets total number of events in the loaded MIDI file.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getTotalEvents\",\n    value: function getTotalEvents() {\n      return this.tracks.reduce(function (a, b) {\n        return {\n          events: {\n            length: a.events.length + b.events.length\n          }\n        };\n      }, {\n        events: {\n          length: 0\n        }\n      }).events.length;\n    }\n    /**\n     * Gets song duration in seconds.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getSongTime\",\n    value: function getSongTime() {\n      return this.totalTicks / this.division / this.tempo * 60;\n    }\n    /**\n     * Gets remaining number of seconds in playback.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getSongTimeRemaining\",\n    value: function getSongTimeRemaining() {\n      return Math.round((this.totalTicks - this.getCurrentTick()) / this.division / this.tempo * 60);\n    }\n    /**\n     * Gets remaining percent of playback.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getSongPercentRemaining\",\n    value: function getSongPercentRemaining() {\n      return Math.round(this.getSongTimeRemaining() / this.getSongTime() * 100);\n    }\n    /**\n     * Number of bytes processed in the loaded MIDI file.\n     * @return {number}\n     */\n\n  }, {\n    key: \"bytesProcessed\",\n    value: function bytesProcessed() {\n      return Constants.HEADER_CHUNK_LENGTH + this.tracks.length * 8 + this.tracks.reduce(function (a, b) {\n        return {\n          pointer: a.pointer + b.pointer\n        };\n      }, {\n        pointer: 0\n      }).pointer;\n    }\n    /**\n     * Number of events played up to this point.\n     * @return {number}\n     */\n\n  }, {\n    key: \"eventsPlayed\",\n    value: function eventsPlayed() {\n      return this.tracks.reduce(function (a, b) {\n        return {\n          eventIndex: a.eventIndex + b.eventIndex\n        };\n      }, {\n        eventIndex: 0\n      }).eventIndex;\n    }\n    /**\n     * Determines if the player pointer has reached the end of the loaded MIDI file.\n     * Used in two ways:\n     * 1. If playing result is based on loaded JSON events.\n     * 2. If parsing (dryRun) it's based on the actual buffer length vs bytes processed.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"endOfFile\",\n    value: function endOfFile() {\n      if (this.isPlaying()) {\n        return this.totalTicks - this.tick <= 0;\n      }\n\n      return this.bytesProcessed() >= this.midiChunksByteLength; //this.buffer.length;\n    }\n    /**\n     * Gets the current tick number in playback.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getCurrentTick\",\n    value: function getCurrentTick() {\n      if (!this.startTime) return this.startTick;\n      return Math.round((new Date().getTime() - this.startTime) / 1000 * (this.division * (this.tempo / 60))) + this.startTick;\n    }\n    /**\n     * Sends MIDI event out to listener.\n     * @param {object}\n     * @return {Player}\n     */\n\n  }, {\n    key: \"emitEvent\",\n    value: function emitEvent(event) {\n      this.triggerPlayerEvent('midiEvent', event);\n      return this;\n    }\n    /**\n     * Subscribes events to listeners\n     * @param {string} - Name of event to subscribe to.\n     * @param {function} - Callback to fire when event is broadcast.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(playerEvent, fn) {\n      if (!this.eventListeners.hasOwnProperty(playerEvent)) this.eventListeners[playerEvent] = [];\n      this.eventListeners[playerEvent].push(fn);\n      return this;\n    }\n    /**\n     * Broadcasts event to trigger subscribed callbacks.\n     * @param {string} - Name of event.\n     * @param {object} - Data to be passed to subscriber callback.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"triggerPlayerEvent\",\n    value: function triggerPlayerEvent(playerEvent, data) {\n      if (this.eventListeners.hasOwnProperty(playerEvent)) this.eventListeners[playerEvent].forEach(function (fn) {\n        return fn(data || {});\n      });\n      return this;\n    }\n  }]);\n\n  return Player;\n}();\n\nvar index = {\n  Player: Player,\n  Utils: Utils,\n  Constants: Constants\n};\n\n\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./node_modules/midi-player-js/build/index.browser.js?");

/***/ }),

/***/ "./src/Files.ts":
/*!**********************!*\
  !*** ./src/Files.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Files = void 0;\r\nvar Files;\r\n(function (Files) {\r\n    function requestUpload(accepts = []) {\r\n        let inp = document.createElement(\"input\");\r\n        inp.type = \"file\";\r\n        inp.accept = accepts.join(\",\");\r\n        inp.click();\r\n        return new Promise(resolve => { inp.onchange = () => { resolve(inp.files); }; });\r\n    }\r\n    Files.requestUpload = requestUpload;\r\n    function download(blob, saveAs) {\r\n        let a = document.createElement(\"a\");\r\n        let url = URL.createObjectURL(blob);\r\n        a.href = url;\r\n        a.download = saveAs;\r\n        a.click();\r\n        URL.revokeObjectURL(url);\r\n    }\r\n    Files.download = download;\r\n    function downloadJSON(json, saveAs) { download(new Blob([JSON.stringify(json)], { type: \"application/json\" }), saveAs); }\r\n    Files.downloadJSON = downloadJSON;\r\n})(Files = exports.Files || (exports.Files = {}));\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/Files.ts?");

/***/ }),

/***/ "./src/audio/AudioManager.ts":
/*!***********************************!*\
  !*** ./src/audio/AudioManager.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.AudioManager = void 0;\r\nvar AudioManager;\r\n(function (AudioManager) {\r\n    AudioManager.Context = new AudioContext({ latencyHint: \"interactive\" });\r\n    async function sampleFromServer(path) {\r\n        let fetchInfo = await fetch(path);\r\n        if (!fetchInfo.ok)\r\n            return null;\r\n        let arrbuff = await fetchInfo.arrayBuffer();\r\n        let sample = await AudioManager.Context.decodeAudioData(arrbuff);\r\n        return sample;\r\n    }\r\n    AudioManager.sampleFromServer = sampleFromServer;\r\n    async function loadSamples() {\r\n        AudioManager.PIANO_SAMPLE = await sampleFromServer(\"334537__teddy-frost__c5.wav\");\r\n    }\r\n    AudioManager.loadSamples = loadSamples;\r\n    function playCheck() { if (AudioManager.Context.state != \"running\")\r\n        AudioManager.Context.resume(); }\r\n    AudioManager.playCheck = playCheck;\r\n    function noteAt(midi, delay, velocity) {\r\n        if (!AudioManager.PIANO_SAMPLE)\r\n            return;\r\n        playCheck();\r\n        let node = AudioManager.Context.createBufferSource();\r\n        node.buffer = AudioManager.PIANO_SAMPLE;\r\n        node.detune.value = (midi - 72) * 100;\r\n        let gain = AudioManager.Context.createGain();\r\n        gain.gain.value = velocity;\r\n        node.connect(gain);\r\n        gain.connect(AudioManager.Context.destination);\r\n        node.start(delay);\r\n    }\r\n    AudioManager.noteAt = noteAt;\r\n})(AudioManager = exports.AudioManager || (exports.AudioManager = {}));\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/audio/AudioManager.ts?");

/***/ }),

/***/ "./src/conversion/MIDIConverter.ts":
/*!*****************************************!*\
  !*** ./src/conversion/MIDIConverter.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.MIDIConverter = void 0;\r\nconst midiPlayerImport = __webpack_require__(/*! midi-player-js */ \"./node_modules/midi-player-js/build/index.browser.js\");\r\nlet midiPlayer = midiPlayerImport.default;\r\n/**\r\n * Convert MIDI file to playable map\r\n */\r\nvar MIDIConverter;\r\n(function (MIDIConverter) {\r\n    function convertFromRaw(info, raw) {\r\n        let map = {\r\n            ...info,\r\n            notes: []\r\n        };\r\n        let player = new midiPlayer.Player(() => { });\r\n        player.loadArrayBuffer(raw);\r\n        let events = player.getEvents();\r\n        // Stage 1\r\n        let midiNotes = [];\r\n        let tempo = 30;\r\n        let minNoteDelta = -1;\r\n        const ticksPerBeat = player.division;\r\n        events.forEach(track => {\r\n            let totalTicks = 0;\r\n            let lastNoteTick = 0;\r\n            let holdingNotes = [];\r\n            for (let i = 0; i < track.length; i++) {\r\n                const event = track[i];\r\n                // @ts-ignore\r\n                const delta = event.delta;\r\n                totalTicks += delta;\r\n                if (event.name == \"Set Tempo\" && event.data > tempo)\r\n                    tempo = event.data;\r\n                function noteOnTrigger() {\r\n                    const lastNoteDelta = totalTicks - lastNoteTick;\r\n                    if (lastNoteDelta > 0) {\r\n                        lastNoteTick = totalTicks;\r\n                        if (minNoteDelta == -1 || minNoteDelta > lastNoteDelta)\r\n                            minNoteDelta = lastNoteDelta;\r\n                    }\r\n                    holdingNotes.push({\r\n                        tick: totalTicks,\r\n                        index: event.noteNumber,\r\n                        velocity: event.velocity || 100,\r\n                        duration: -1\r\n                    });\r\n                }\r\n                function noteOffTrigger() {\r\n                    let noteIdx = holdingNotes.findIndex(v => v.index == event.noteNumber);\r\n                    if (noteIdx == -1)\r\n                        return;\r\n                    let [note] = holdingNotes.splice(noteIdx, 1);\r\n                    note.duration = totalTicks - note.tick;\r\n                    midiNotes.push(note);\r\n                }\r\n                if (event.name == \"Note on\") {\r\n                    if (event.velocity <= 0)\r\n                        noteOffTrigger();\r\n                    else\r\n                        noteOnTrigger();\r\n                }\r\n                if (event.name == \"Note off\") {\r\n                    noteOffTrigger();\r\n                }\r\n            }\r\n        });\r\n        if (minNoteDelta == -1)\r\n            minNoteDelta = ticksPerBeat / 4;\r\n        const notesPerBeat = ticksPerBeat / minNoteDelta;\r\n        map.initialSpeed = tempo * notesPerBeat / 60;\r\n        map.scrollAcceleration = 0.002;\r\n        let noteOffScale = 1;\r\n        while (map.initialSpeed > 6) {\r\n            map.initialSpeed /= 2;\r\n            noteOffScale /= 2;\r\n        }\r\n        while (map.initialSpeed < 1) {\r\n            map.initialSpeed *= 2;\r\n            noteOffScale *= 2;\r\n        }\r\n        midiNotes.forEach((midi, idx) => {\r\n            const lane = midi.index % 4;\r\n            const offset = Math.floor(midi.tick / minNoteDelta * noteOffScale);\r\n            const duration = Math.max(Math.floor(midi.duration / minNoteDelta * noteOffScale), 1);\r\n            let note = map.notes.find(v => v.offset == offset);\r\n            if (!note) {\r\n                let note = {\r\n                    index: lane,\r\n                    offset,\r\n                    midi: [{ index: midi.index, velocity: midi.velocity / 100 }],\r\n                    duration: 1\r\n                };\r\n                map.notes.push(note);\r\n            }\r\n            else {\r\n                note.midi.push({ index: midi.index, velocity: midi.velocity / 100 });\r\n                let totalMid = 0;\r\n                note.midi.forEach(a => totalMid += a.index);\r\n                note.index = totalMid % 4;\r\n                if (duration > note.duration)\r\n                    note.duration = duration;\r\n            }\r\n        });\r\n        // Striping\r\n        let firstNote = map.notes[0];\r\n        const reoffset = firstNote.offset;\r\n        map.notes.forEach((note) => { note.offset -= reoffset; });\r\n        // Finalize\r\n        map.notes.sort((a, b) => a.offset - b.offset);\r\n        map.notes.forEach((note, i) => {\r\n            let prev = map.notes[i - 1];\r\n            if (!prev)\r\n                return;\r\n            if (prev.offset + prev.duration > note.offset)\r\n                prev.duration = note.offset - prev.offset;\r\n        });\r\n        return map;\r\n    }\r\n    MIDIConverter.convertFromRaw = convertFromRaw;\r\n})(MIDIConverter = exports.MIDIConverter || (exports.MIDIConverter = {}));\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/conversion/MIDIConverter.ts?");

/***/ }),

/***/ "./src/engine/GameMap.ts":
/*!*******************************!*\
  !*** ./src/engine/GameMap.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.TEST_MAP = void 0;\r\nexports.TEST_MAP = {\r\n    title: \"Test Map\",\r\n    author: \"nahkd123\",\r\n    id: \"default-test-map\",\r\n    initialSpeed: 1.6,\r\n    scrollAcceleration: 0.02,\r\n    notes: [\r\n        { offset: 0, index: 0, duration: 2, midi: [] },\r\n        { offset: 0, index: 2, duration: 2, midi: [] },\r\n        { offset: 2, index: 1, duration: 2, midi: [] },\r\n        { offset: 2, index: 3, duration: 2, midi: [] },\r\n        { offset: 4, index: 0, midi: [] },\r\n        { offset: 5, index: 1, midi: [] },\r\n        { offset: 6, index: 2, midi: [] },\r\n        { offset: 7, index: 3, midi: [] },\r\n        { offset: 8, index: 2, midi: [] },\r\n        { offset: 9, index: 1, midi: [] },\r\n        { offset: 10, index: 0, midi: [] },\r\n        { offset: 11, index: 2, midi: [] },\r\n        { offset: 12, index: 1, midi: [] },\r\n        { offset: 13, index: 3, midi: [] },\r\n        { offset: 14, index: 0, midi: [] },\r\n        { offset: 15, index: 1, midi: [] },\r\n        { offset: 16, index: 3, midi: [] },\r\n        { offset: 17, index: 2, midi: [] },\r\n        { offset: 18, index: 1, midi: [] },\r\n        { offset: 19, index: 2, midi: [] },\r\n        { offset: 20, index: 1, midi: [] },\r\n        { offset: 21, index: 0, midi: [] },\r\n        { offset: 21, index: 2, midi: [] },\r\n        { offset: 22, index: 1, midi: [] },\r\n        { offset: 22, index: 3, midi: [] },\r\n        { offset: 23, index: 0, midi: [] },\r\n        { offset: 23, index: 2, midi: [] },\r\n        { offset: 24, index: 1, midi: [] },\r\n        { offset: 24, index: 3, midi: [] },\r\n        { offset: 25, index: 0, midi: [] },\r\n        { offset: 25, index: 2, midi: [] },\r\n        { offset: 26, index: 1, midi: [] },\r\n        { offset: 26, index: 3, midi: [] },\r\n        { offset: 27, index: 0, midi: [] },\r\n        { offset: 27, index: 2, midi: [] },\r\n        { offset: 28, index: 1, midi: [] },\r\n        { offset: 28, index: 3, midi: [] },\r\n    ]\r\n};\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/engine/GameMap.ts?");

/***/ }),

/***/ "./src/engine/MapStore.ts":
/*!********************************!*\
  !*** ./src/engine/MapStore.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.IDBMapStore = exports.SimpleMapStore = exports.MapStore = void 0;\r\nconst idb_1 = __webpack_require__(/*! idb */ \"./node_modules/idb/build/index.js\");\r\nconst GameMap_1 = __webpack_require__(/*! ./GameMap */ \"./src/engine/GameMap.ts\");\r\nclass MapStore {\r\n}\r\nexports.MapStore = MapStore;\r\nclass SimpleMapStore extends MapStore {\r\n    maps = [\r\n        { ...GameMap_1.TEST_MAP, id: \"0\" }\r\n    ];\r\n    async queryMaps(info) {\r\n        const title = info.title ?? \"\";\r\n        const author = info.author ?? \"\";\r\n        return this.maps.filter(v => v.title.includes(title) && v.author.includes(author));\r\n    }\r\n    async getMap(info) { return this.maps.find(v => v.id == info.id); }\r\n    async putMap(map) {\r\n        const prevIdx = this.maps.findIndex(v => v.id == map.id);\r\n        if (prevIdx != -1)\r\n            this.maps.splice(prevIdx, 1, map);\r\n        else\r\n            this.maps.push(map);\r\n        return true;\r\n    }\r\n    async deleteMap(map) {\r\n        const prevIdx = this.maps.findIndex(v => v.id == map.id);\r\n        if (prevIdx != -1) {\r\n            this.maps.splice(prevIdx, 1);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.SimpleMapStore = SimpleMapStore;\r\nclass IDBMapStore extends MapStore {\r\n    db;\r\n    constructor() {\r\n        super();\r\n    }\r\n    async loadIDB() {\r\n        this.db = await (0, idb_1.openDB)(\"nahkd-piano-tiles\", 1, {\r\n            upgrade(db, old, newV, tx) {\r\n                let store = db.createObjectStore(\"maps\", { keyPath: \"id\" });\r\n                store.put(GameMap_1.TEST_MAP);\r\n            }\r\n        });\r\n    }\r\n    async queryMaps(info) {\r\n        const title = info.title ?? \"\";\r\n        const author = info.author ?? \"\";\r\n        let tx = this.db.transaction(\"maps\", \"readonly\");\r\n        let store = tx.objectStore(\"maps\");\r\n        let cursor = await store.openCursor();\r\n        let maps = [];\r\n        while (cursor && cursor.value) {\r\n            let map = cursor.value;\r\n            if (map.title.includes(title) && map.author.includes(author))\r\n                maps.push(cursor.value);\r\n            cursor = await cursor.continue();\r\n        }\r\n        return maps;\r\n    }\r\n    async getMap(info) {\r\n        let tx = this.db.transaction(\"maps\", \"readonly\");\r\n        let store = tx.objectStore(\"maps\");\r\n        let map = await store.get(info.id);\r\n        return map;\r\n    }\r\n    async putMap(map) {\r\n        let tx = this.db.transaction(\"maps\", \"readwrite\");\r\n        let store = tx.objectStore(\"maps\");\r\n        await store.put(map);\r\n        return true;\r\n    }\r\n    async deleteMap(map) {\r\n        let tx = this.db.transaction(\"maps\", \"readwrite\");\r\n        let store = tx.objectStore(\"maps\");\r\n        await store.delete(map.id);\r\n        return true;\r\n    }\r\n}\r\nexports.IDBMapStore = IDBMapStore;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/engine/MapStore.ts?");

/***/ }),

/***/ "./src/engine/modifiers/ModConstantSpeed.ts":
/*!**************************************************!*\
  !*** ./src/engine/modifiers/ModConstantSpeed.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModConstantSpeed = void 0;\r\nconst Modifier_1 = __webpack_require__(/*! ./Modifier */ \"./src/engine/modifiers/Modifier.ts\");\r\nclass ModConstantSpeed extends Modifier_1.Modifier {\r\n    name = \"Constant Speed\";\r\n    description = \"Play without speed changes\";\r\n    selectedColor = \"#9cff9c\";\r\n    modifyOptions(opt) { opt.scrollAcceleration = 0; }\r\n}\r\nexports.ModConstantSpeed = ModConstantSpeed;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/engine/modifiers/ModConstantSpeed.ts?");

/***/ }),

/***/ "./src/engine/modifiers/ModDoubleSpeed.ts":
/*!************************************************!*\
  !*** ./src/engine/modifiers/ModDoubleSpeed.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModDoubleSpeed = void 0;\r\nconst Modifier_1 = __webpack_require__(/*! ./Modifier */ \"./src/engine/modifiers/Modifier.ts\");\r\nclass ModDoubleSpeed extends Modifier_1.Modifier {\r\n    name = \"Double Speed\";\r\n    description = \"Double the notes per second\";\r\n    selectedColor = \"#ff9c9c\";\r\n    modifyOptions(opt) {\r\n        opt.initialSpeed *= 2;\r\n        opt.scrollAcceleration *= 1.05;\r\n    }\r\n}\r\nexports.ModDoubleSpeed = ModDoubleSpeed;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/engine/modifiers/ModDoubleSpeed.ts?");

/***/ }),

/***/ "./src/engine/modifiers/ModLives.ts":
/*!******************************************!*\
  !*** ./src/engine/modifiers/ModLives.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModLives = void 0;\r\nconst Modifier_1 = __webpack_require__(/*! ./Modifier */ \"./src/engine/modifiers/Modifier.ts\");\r\nclass ModLives extends Modifier_1.Modifier {\r\n    name = \"5x Lives\";\r\n    description = \"You can only miss 5 notes\";\r\n    selectedColor = \"#9cff9c\";\r\n    onNoteMiss(playfield) {\r\n        let lives = playfield.modifiersStorage[\"nahkd123::lives\"] ?? 5;\r\n        if (lives > 0) {\r\n            lives--;\r\n            playfield.modifiersStorage[\"nahkd123::lives\"] = lives;\r\n            navigator.vibrate([80]);\r\n            return false;\r\n        }\r\n        else\r\n            return true;\r\n    }\r\n}\r\nexports.ModLives = ModLives;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/engine/modifiers/ModLives.ts?");

/***/ }),

/***/ "./src/engine/modifiers/ModNoFail.ts":
/*!*******************************************!*\
  !*** ./src/engine/modifiers/ModNoFail.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModNoFail = void 0;\r\nconst Modifier_1 = __webpack_require__(/*! ./Modifier */ \"./src/engine/modifiers/Modifier.ts\");\r\nclass ModNoFail extends Modifier_1.Modifier {\r\n    name = \"No Fail\";\r\n    description = \"You can no longer fail\";\r\n    selectedColor = \"#9cff9c\";\r\n    onNoteMiss() { return false; }\r\n}\r\nexports.ModNoFail = ModNoFail;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/engine/modifiers/ModNoFail.ts?");

/***/ }),

/***/ "./src/engine/modifiers/ModShuffle.ts":
/*!********************************************!*\
  !*** ./src/engine/modifiers/ModShuffle.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModShuffle = void 0;\r\nconst Modifier_1 = __webpack_require__(/*! ./Modifier */ \"./src/engine/modifiers/Modifier.ts\");\r\nclass ModShuffle extends Modifier_1.Modifier {\r\n    name = \"Shuffle\";\r\n    description = \"Shuffle notes around\";\r\n    selectedColor = \"#ff9cff\";\r\n    processNotes(notes) {\r\n        let notesAt = (offset) => {\r\n            return notes.filter(v => offset >= v.offset && offset < (v.offset + Math.max(v.duration || 1, 1)));\r\n        };\r\n        const offsetStart = notes[0].offset;\r\n        const offsetEnd = notes.at(-1).offset + Math.max(notes.at(-1).duration || 1, 1);\r\n        const frozenNotes = [];\r\n        for (let i = offsetStart; i < offsetEnd; i++) {\r\n            const notes = notesAt(i);\r\n            const changes = notes.filter(v => !frozenNotes.includes(v));\r\n            let isOccupied = (skip, lane) => {\r\n                return notes.some(v => v != skip && v.index == lane);\r\n            };\r\n            changes.forEach(n => {\r\n                let newLane;\r\n                do\r\n                    newLane = Math.floor(Math.random() * 4);\r\n                while (isOccupied(n, newLane));\r\n                n.index = newLane;\r\n                frozenNotes.push(n);\r\n            });\r\n        }\r\n    }\r\n}\r\nexports.ModShuffle = ModShuffle;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/engine/modifiers/ModShuffle.ts?");

/***/ }),

/***/ "./src/engine/modifiers/ModSlow.ts":
/*!*****************************************!*\
  !*** ./src/engine/modifiers/ModSlow.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModSlow = void 0;\r\nconst Modifier_1 = __webpack_require__(/*! ./Modifier */ \"./src/engine/modifiers/Modifier.ts\");\r\nclass ModSlow extends Modifier_1.Modifier {\r\n    name = \"Slow\";\r\n    description = \"Halves the notes per second\";\r\n    selectedColor = \"#9cff9c\";\r\n    modifyOptions(opt) {\r\n        opt.initialSpeed /= 2;\r\n        opt.scrollAcceleration /= 1.5;\r\n    }\r\n}\r\nexports.ModSlow = ModSlow;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/engine/modifiers/ModSlow.ts?");

/***/ }),

/***/ "./src/engine/modifiers/Modifier.ts":
/*!******************************************!*\
  !*** ./src/engine/modifiers/Modifier.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Modifier = void 0;\r\nclass Modifier {\r\n    selectedColor = \"#ffcaca\";\r\n    /**\r\n     * Modify the playfield options\r\n     * @param opt The playfield options\r\n     */\r\n    modifyOptions(opt) { }\r\n    /**\r\n     * Process next notes. You shouldn't touch the note offset, unless you're making\r\n     * swing modifier (which is cool I think)\r\n     * @param notes Notes to process\r\n     */\r\n    processNotes(notes) { }\r\n    /**\r\n     * Triggered when player miss a note\r\n     * @param playfield The playfield with active modifier\r\n     * @returns true will play fail animation\r\n     */\r\n    onNoteMiss(playfield) { return true; }\r\n    static modifiers = [];\r\n    static registerModifier(mod) { this.modifiers.push(mod); }\r\n}\r\nexports.Modifier = Modifier;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/engine/modifiers/Modifier.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.mapStore = void 0;\r\nconst MapStore_1 = __webpack_require__(/*! ./engine/MapStore */ \"./src/engine/MapStore.ts\");\r\nconst BackButton_1 = __webpack_require__(/*! ./ui/BackButton */ \"./src/ui/BackButton.ts\");\r\nconst AudioManager_1 = __webpack_require__(/*! ./audio/AudioManager */ \"./src/audio/AudioManager.ts\");\r\nconst HomeScreen_1 = __webpack_require__(/*! ./ui/screens/HomeScreen */ \"./src/ui/screens/HomeScreen.ts\");\r\nconst Modifier_1 = __webpack_require__(/*! ./engine/modifiers/Modifier */ \"./src/engine/modifiers/Modifier.ts\");\r\nconst ModNoFail_1 = __webpack_require__(/*! ./engine/modifiers/ModNoFail */ \"./src/engine/modifiers/ModNoFail.ts\");\r\nconst ModSlow_1 = __webpack_require__(/*! ./engine/modifiers/ModSlow */ \"./src/engine/modifiers/ModSlow.ts\");\r\nconst ModShuffle_1 = __webpack_require__(/*! ./engine/modifiers/ModShuffle */ \"./src/engine/modifiers/ModShuffle.ts\");\r\nconst ModConstantSpeed_1 = __webpack_require__(/*! ./engine/modifiers/ModConstantSpeed */ \"./src/engine/modifiers/ModConstantSpeed.ts\");\r\nconst ModDoubleSpeed_1 = __webpack_require__(/*! ./engine/modifiers/ModDoubleSpeed */ \"./src/engine/modifiers/ModDoubleSpeed.ts\");\r\nconst ModLives_1 = __webpack_require__(/*! ./engine/modifiers/ModLives */ \"./src/engine/modifiers/ModLives.ts\");\r\nexports.mapStore = new MapStore_1.IDBMapStore();\r\nPromise.all([\r\n    AudioManager_1.AudioManager.loadSamples(),\r\n    exports.mapStore.loadIDB()\r\n]).then(() => {\r\n    Modifier_1.Modifier.registerModifier(new ModNoFail_1.ModNoFail());\r\n    Modifier_1.Modifier.registerModifier(new ModLives_1.ModLives());\r\n    Modifier_1.Modifier.registerModifier(new ModSlow_1.ModSlow());\r\n    Modifier_1.Modifier.registerModifier(new ModConstantSpeed_1.ModConstantSpeed());\r\n    Modifier_1.Modifier.registerModifier(new ModDoubleSpeed_1.ModDoubleSpeed());\r\n    Modifier_1.Modifier.registerModifier(new ModShuffle_1.ModShuffle());\r\n    document.body.append(BackButton_1.BACK_BUTTON.element);\r\n    let screen = new HomeScreen_1.HomeScreen();\r\n    screen.push();\r\n});\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/index.ts?");

/***/ }),

/***/ "./src/ui/BackButton.ts":
/*!******************************!*\
  !*** ./src/ui/BackButton.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BACK_BUTTON = exports.BackButton = void 0;\r\nconst Screen_1 = __webpack_require__(/*! ./Screen */ \"./src/ui/Screen.ts\");\r\nclass BackButton {\r\n    element;\r\n    constructor() {\r\n        this.element = document.createElement(\"div\");\r\n        this.element.className = \"backbutton invisible\";\r\n        this.element.textContent = \"< Back\";\r\n        this.element.addEventListener(\"click\", () => {\r\n            Screen_1.Screen.pop();\r\n            if (Screen_1.Screen.getStack().length <= 1 || Screen_1.Screen.getStack().at(-1).hideBack)\r\n                this.hide();\r\n        });\r\n    }\r\n    show() {\r\n        this.element.classList.add(\"invisibleFinal\");\r\n        this.element.classList.remove(\"invisible\");\r\n        setTimeout(() => this.element.classList.remove(\"invisibleFinal\"));\r\n    }\r\n    hide() {\r\n        this.element.classList.add(\"invisibleFinal\");\r\n        setTimeout(() => {\r\n            this.element.classList.remove(\"invisibleFinal\");\r\n            this.element.classList.add(\"invisible\");\r\n        }, 200);\r\n    }\r\n}\r\nexports.BackButton = BackButton;\r\nexports.BACK_BUTTON = new BackButton();\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/BackButton.ts?");

/***/ }),

/***/ "./src/ui/Playfield.ts":
/*!*****************************!*\
  !*** ./src/ui/Playfield.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Playfield = void 0;\r\nconst AudioManager_1 = __webpack_require__(/*! ../audio/AudioManager */ \"./src/audio/AudioManager.ts\");\r\nconst Skin_1 = __webpack_require__(/*! ./Skin */ \"./src/ui/Skin.ts\");\r\n/**\r\n * A simple playfield. It can also be used as editor (if you wish)\r\n */\r\nclass Playfield {\r\n    map;\r\n    options;\r\n    modifiersStorage = {};\r\n    container;\r\n    scoreDisplay;\r\n    speedDisplay;\r\n    canvas;\r\n    ctx;\r\n    skin = new Skin_1.DefaultSkin();\r\n    canvasScale = 1;\r\n    notes = [];\r\n    lastNote;\r\n    holdNotes = [];\r\n    hitAnimations = [];\r\n    score = 0;\r\n    time = 0;\r\n    scrollPosition = 0;\r\n    nextNote = 0;\r\n    isStarted = false;\r\n    debugIndex = -1;\r\n    debugOffset = 0;\r\n    failed = false;\r\n    failedIndex = -1;\r\n    failedOffset = -1;\r\n    failedTime = -1;\r\n    failedCallback;\r\n    constructor(map, options = {}) {\r\n        this.map = map;\r\n        this.options = options;\r\n        this.options = {\r\n            initialSpeed: map.initialSpeed,\r\n            scrollAcceleration: map.scrollAcceleration,\r\n            judgementLine: false,\r\n            modifiers: [],\r\n            ...options\r\n        };\r\n        this.options.modifiers.forEach(mod => mod.modifyOptions(this.options));\r\n        this.lastNote = {\r\n            index: 0,\r\n            offset: -9,\r\n            midi: [],\r\n            duration: 1\r\n        };\r\n        this.applyLoop();\r\n        this.scrollPosition = this.scrollPositionAtTime(0);\r\n        this.container = document.createElement(\"div\");\r\n        this.container.className = \"container playfield\";\r\n        this.canvas = document.createElement(\"canvas\");\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n        this.canvasScale = devicePixelRatio;\r\n        this.scoreDisplay = document.createElement(\"div\");\r\n        this.scoreDisplay.className = \"display score\";\r\n        this.scoreDisplay.textContent = `${this.score}`;\r\n        this.speedDisplay = document.createElement(\"div\");\r\n        this.speedDisplay.className = \"display speed\";\r\n        this.speedDisplay.textContent = `${this.speedAtTimeDisplay(this.time)} n/s`;\r\n        this.container.append(this.canvas, this.scoreDisplay, this.speedDisplay);\r\n        let observer = new ResizeObserver(() => { this.renderCanvas(); });\r\n        observer.observe(this.canvas);\r\n        this.canvas.addEventListener(\"pointerup\", event => {\r\n            const holdIdx = this.holdNotes.findIndex(v => v.pointerId == event.pointerId);\r\n            if (holdIdx == -1)\r\n                return;\r\n            const width = this.canvas.width;\r\n            const height = this.canvas.height;\r\n            const noteWidth = width / 4;\r\n            const noteBaseHeight = noteWidth * 1.75;\r\n            const hold = this.holdNotes[holdIdx];\r\n            const note = hold.note;\r\n            const noteDuration = Math.max(note.duration || 1, 1);\r\n            const noteY = height - (note.offset + noteDuration - this.scrollPosition) * noteBaseHeight;\r\n            const pointerCHeight = Math.floor(hold.pointerY * this.canvasScale);\r\n            const prog = 1 - (pointerCHeight - noteY) / (noteBaseHeight * noteDuration);\r\n            this.hitAnimations.push({\r\n                note: hold.note,\r\n                timestamp: -1,\r\n                holdProgress: prog\r\n            });\r\n            this.score += Math.floor((noteDuration - 1) * (prog + 0.5)); // TODO: add based on prog\r\n            this.scoreDisplay.textContent = `${this.score}`;\r\n            this.holdNotes.splice(holdIdx, 1);\r\n        });\r\n        this.canvas.addEventListener(\"pointerdown\", event => {\r\n            if (this.failed)\r\n                return;\r\n            const width = this.canvas.offsetWidth;\r\n            const height = this.canvas.offsetHeight;\r\n            const noteWidth = width / 4;\r\n            const noteHeight = noteWidth * 1.75;\r\n            const noteIndex = Math.floor(event.offsetX / noteWidth);\r\n            const noteOffset = (height - event.offsetY) / noteHeight + this.scrollPosition;\r\n            this.debugIndex = noteIndex;\r\n            this.debugOffset = noteOffset;\r\n            const note = this.noteAt(noteOffset, noteIndex);\r\n            if (note != -1) {\r\n                const prevNote = this.notes[note - 1];\r\n                if (prevNote && prevNote.offset < this.notes[note].offset && this.checkFail()) {\r\n                    this.failed = true;\r\n                    this.failedIndex = noteIndex;\r\n                    this.failedOffset = Math.floor(noteOffset);\r\n                }\r\n                else {\r\n                    this.score++;\r\n                    this.scoreDisplay.textContent = `${this.score}`;\r\n                    this.notes[note].midi?.forEach(midi => {\r\n                        AudioManager_1.AudioManager.noteAt(midi.index, 0, midi.velocity);\r\n                    });\r\n                    if (Math.max(this.notes[note].duration || 1, 1) == 1) {\r\n                        this.hitAnimations.push({\r\n                            note: this.notes[note],\r\n                            timestamp: -1\r\n                        });\r\n                    }\r\n                    else {\r\n                        this.holdNotes.push({\r\n                            note: this.notes[note],\r\n                            pointerId: event.pointerId,\r\n                            pointerY: event.offsetY\r\n                        });\r\n                    }\r\n                }\r\n                this.notes.splice(note, 1);\r\n                this.applyLoop();\r\n            }\r\n            else if (this.checkFail()) {\r\n                this.failed = true;\r\n                this.failedIndex = noteIndex;\r\n                this.failedOffset = Math.floor(noteOffset);\r\n            }\r\n            if (!this.isStarted)\r\n                this.start();\r\n        });\r\n    }\r\n    checkFail() {\r\n        if (this.options.modifiers.length == 0)\r\n            return true;\r\n        for (let i = 0; i < this.options.modifiers.length; i++)\r\n            if (this.options.modifiers[i].onNoteMiss(this))\r\n                return true;\r\n        return false;\r\n    }\r\n    renderCanvas() {\r\n        const ctx = this.ctx;\r\n        if (this.canvas.width != Math.floor(this.canvas.offsetWidth * this.canvasScale) ||\r\n            this.canvas.height != Math.floor(this.canvas.offsetHeight * this.canvasScale)) {\r\n            this.canvas.width = Math.floor(this.canvas.offsetWidth * this.canvasScale);\r\n            this.canvas.height = Math.floor(this.canvas.offsetHeight * this.canvasScale);\r\n        }\r\n        const width = this.canvas.width;\r\n        const height = this.canvas.height;\r\n        const noteWidth = width / 4;\r\n        const noteBaseHeight = noteWidth * 1.75;\r\n        const renderScale = noteWidth / 100;\r\n        ctx.clearRect(0, 0, width, height);\r\n        ctx.scale(width / 100, height / 100);\r\n        this.skin.drawBackground(ctx);\r\n        ctx.scale(100 / width, 100 / height);\r\n        // Bar lines\r\n        const visibleNotes = Math.floor(height / noteBaseHeight) + 1;\r\n        const topOffset = 1 - (this.scrollPosition % 1);\r\n        for (let i = 0; i < visibleNotes; i++) {\r\n            ctx.translate(0, height - (topOffset + i) * noteBaseHeight);\r\n            ctx.scale(width / 100, height / 100);\r\n            this.skin.drawBarLine(ctx);\r\n            ctx.scale(100 / width, 100 / height);\r\n            ctx.translate(0, -(height - (topOffset + i) * noteBaseHeight));\r\n        }\r\n        // Lanes\r\n        for (let i = 0; i < 4; i++) {\r\n            ctx.translate(noteWidth * i, 0);\r\n            ctx.scale(width / 100, height / 100);\r\n            this.skin.drawLaneSeperator(ctx);\r\n            ctx.scale(100 / width, 100 / height);\r\n            ctx.translate(-(noteWidth * i), 0);\r\n        }\r\n        let missedNotes = [];\r\n        for (let i = 0; i < this.notes.length; i++) {\r\n            if (this.nextNote > i)\r\n                continue;\r\n            const note = this.notes[i];\r\n            const noteDuration = Math.max(note.duration || 1, 1);\r\n            const noteX = noteWidth * note.index;\r\n            const noteY = height - (note.offset + noteDuration - this.scrollPosition) * noteBaseHeight;\r\n            if (noteY > height) {\r\n                if (this.checkFail()) {\r\n                    this.failed = true;\r\n                    this.failedIndex = note.index;\r\n                    this.failedOffset = note.offset;\r\n                }\r\n                missedNotes.push(note);\r\n            }\r\n            if (noteY + noteBaseHeight * noteDuration < 0)\r\n                break;\r\n            ctx.translate(noteX, noteY);\r\n            ctx.scale(renderScale, renderScale);\r\n            this.skin.drawNote(ctx, noteDuration, 0.0);\r\n            ctx.scale(1 / renderScale, 1 / renderScale);\r\n            ctx.translate(-noteX, -noteY);\r\n        }\r\n        for (let i = 0; i < missedNotes.length; i++) {\r\n            const n = missedNotes[i];\r\n            const idx = this.notes.indexOf(n);\r\n            if (idx == -1)\r\n                return;\r\n            this.notes.splice(idx, 1);\r\n        }\r\n        this.holdNotes.forEach(hold => {\r\n            const note = hold.note;\r\n            const noteDuration = Math.max(note.duration || 1, 1);\r\n            const noteX = noteWidth * note.index;\r\n            const noteY = height - (note.offset + noteDuration - this.scrollPosition) * noteBaseHeight;\r\n            ctx.translate(noteX, noteY);\r\n            ctx.scale(renderScale, renderScale);\r\n            const pointerCHeight = Math.floor(hold.pointerY * this.canvasScale);\r\n            const prog = 1 - (pointerCHeight - noteY) / (noteBaseHeight * noteDuration);\r\n            this.skin.drawNote(ctx, noteDuration, prog);\r\n            ctx.scale(1 / renderScale, 1 / renderScale);\r\n            ctx.translate(-noteX, -noteY);\r\n        });\r\n        ctx.resetTransform();\r\n    }\r\n    scrollPositionAtTime(t) {\r\n        return this.options.initialSpeed * t + (this.options.scrollAcceleration * (t ** 2)) / 2 - 1;\r\n    }\r\n    speedAtTimeDisplay(t) {\r\n        const val = this.options.initialSpeed + this.options.scrollAcceleration * t;\r\n        return val.toFixed(1);\r\n    }\r\n    noteAt(offset, lane) {\r\n        return this.notes.findIndex(v => {\r\n            if (v.index != lane)\r\n                return;\r\n            const offsetEnd = v.offset + (v.duration || 1);\r\n            return offset >= v.offset && offset < offsetEnd;\r\n        });\r\n    }\r\n    start() {\r\n        let beginTimestamp = -1;\r\n        let render = (ts) => {\r\n            if (beginTimestamp == -1) {\r\n                beginTimestamp = ts;\r\n                window.requestAnimationFrame(render);\r\n                return;\r\n            }\r\n            const ctx = this.ctx;\r\n            const width = this.canvas.width;\r\n            const height = this.canvas.height;\r\n            const noteWidth = width / 4;\r\n            const noteHeight = noteWidth * 1.75;\r\n            const renderScale = noteWidth / 100;\r\n            this.renderCanvas();\r\n            if (!this.failed) {\r\n                this.time = (ts - beginTimestamp) / 1000;\r\n                this.scrollPosition = this.scrollPositionAtTime(this.time);\r\n                this.speedDisplay.textContent = `${this.speedAtTimeDisplay(this.time)} n/s`;\r\n            }\r\n            else {\r\n                if (this.failedTime == -1)\r\n                    this.failedTime = ts;\r\n                const failedDuration = ts - this.failedTime;\r\n                const failAlpha = failedDuration < 200 ? failedDuration / 200 : 1;\r\n                const targetScroll = Math.floor(this.failedOffset - 1);\r\n                this.scrollPosition = failedDuration < 500 ? this.scrollPosition * 0.8 + targetScroll * 0.2 : targetScroll;\r\n                ctx.fillStyle = `hsla(0, 100%, ${50 + Math.abs(Math.sin(failedDuration / 200) * 30)}%, ${failAlpha})`;\r\n                ctx.fillRect(this.failedIndex * noteWidth, height - (this.failedOffset + 1 - this.scrollPosition) * noteHeight, noteWidth, noteHeight);\r\n                if (failedDuration > 1800) {\r\n                    if (this.failedCallback)\r\n                        this.failedCallback();\r\n                    return;\r\n                }\r\n            }\r\n            this.hitAnimations.forEach(hit => {\r\n                if (hit.timestamp == -1)\r\n                    hit.timestamp = ts;\r\n                const noteTime = ts - hit.timestamp;\r\n                const noteScale = Math.sqrt(noteTime / 200) * Math.min(this.score / 200, 0.6);\r\n                const noteScaleAdd = 1 + noteScale;\r\n                const noteDuration = Math.max(hit.note.duration || 1, 1);\r\n                const noteX = noteWidth * hit.note.index - noteWidth / 2 * noteScale;\r\n                const noteY = height - (hit.note.offset + noteDuration - this.scrollPosition) * noteHeight - noteHeight / 2 * noteScale;\r\n                ctx.translate(noteX, noteY);\r\n                ctx.scale(renderScale * noteScaleAdd, renderScale * noteScaleAdd);\r\n                ctx.globalAlpha = Math.max(1.0 - noteTime / 200, 0.0);\r\n                this.skin.drawNote(ctx, noteDuration, hit.holdProgress ?? 0.0);\r\n                ctx.globalAlpha = 1.0;\r\n                ctx.scale(1 / (renderScale * noteScaleAdd), 1 / (renderScale * noteScaleAdd));\r\n                ctx.translate(-noteX, -noteY);\r\n            });\r\n            this.hitAnimations.filter(v => (ts - v.timestamp) >= 200).forEach(hit => {\r\n                this.hitAnimations.splice(this.hitAnimations.indexOf(hit), 1);\r\n            });\r\n            window.requestAnimationFrame(render);\r\n        };\r\n        window.requestAnimationFrame(render);\r\n        this.isStarted = true;\r\n    }\r\n    applyLoop() {\r\n        if (this.notes.length > 0)\r\n            return;\r\n        const lastNoteEnd = this.lastNote.offset + Math.max(this.lastNote.duration || 1, 1);\r\n        this.map.notes.forEach(note => {\r\n            this.notes.push({\r\n                ...note,\r\n                offset: lastNoteEnd + 8 + note.offset\r\n            });\r\n        });\r\n        this.lastNote = this.notes[this.notes.length - 1];\r\n        this.options.modifiers.forEach(mod => mod.processNotes(this.notes));\r\n    }\r\n}\r\nexports.Playfield = Playfield;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/Playfield.ts?");

/***/ }),

/***/ "./src/ui/QuickElement.ts":
/*!********************************!*\
  !*** ./src/ui/QuickElement.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.QuickElement = void 0;\r\nvar QuickElement;\r\n(function (QuickElement) {\r\n    function header(title, desc, mini = false) {\r\n        let e = document.createElement(\"div\");\r\n        e.className = \"header\";\r\n        if (mini)\r\n            e.classList.add(\"mini\");\r\n        let t = document.createElement(\"div\");\r\n        t.className = \"title\";\r\n        t.textContent = title;\r\n        let d = document.createElement(\"div\");\r\n        d.className = \"description\";\r\n        d.textContent = desc;\r\n        e.append(t, d);\r\n        return e;\r\n    }\r\n    QuickElement.header = header;\r\n})(QuickElement = exports.QuickElement || (exports.QuickElement = {}));\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/QuickElement.ts?");

/***/ }),

/***/ "./src/ui/Screen.ts":
/*!**************************!*\
  !*** ./src/ui/Screen.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Screen = void 0;\r\nconst SCREENS_STACK = [];\r\nclass Screen {\r\n    hideBack = false;\r\n    parent;\r\n    contents;\r\n    constructor() {\r\n        this.parent = document.createElement(\"div\");\r\n        this.parent.className = \"screen pop\";\r\n        this.contents = document.createElement(\"div\");\r\n        this.parent.appendChild(this.contents);\r\n    }\r\n    screenPushAnimation() { this.parent.classList.remove(\"pop\"); }\r\n    screenPopAnimation() { this.parent.classList.add(\"pop\"); }\r\n    push() {\r\n        document.body.appendChild(this.parent);\r\n        SCREENS_STACK.push(this);\r\n        setTimeout(() => this.screenPushAnimation());\r\n    }\r\n    static pop() {\r\n        let screen = SCREENS_STACK.pop();\r\n        screen.screenPopAnimation();\r\n        setTimeout(() => screen.parent.remove(), 200);\r\n        return screen;\r\n    }\r\n    static getStack() { return SCREENS_STACK; }\r\n}\r\nexports.Screen = Screen;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/Screen.ts?");

/***/ }),

/***/ "./src/ui/Skin.ts":
/*!************************!*\
  !*** ./src/ui/Skin.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DefaultSkin = exports.Skin = void 0;\r\n/**\r\n * Skinning. There're some stuffs that I want to point out:\r\n * - The note ratio is always 1:1.75 (Width:Height)\r\n * - All drawing operations starts from 0:0 (unless you call resetTransform)\r\n * - Instead of regular pixels, we use points (pt). Eg: drawNote has 100x175pt\r\n */\r\nclass Skin {\r\n    /**\r\n     * Draw note with ``width = 100pt`` and ``height = length * 175pt``\r\n     * @param ctx The canvas context\r\n     * @param length Note length. The length in pt is 175 * length\r\n     * @param holdProgress Hold progress from 0.0 (not holding) to 1.0.\r\n     */\r\n    drawNote(ctx, length, holdProgress) {\r\n        if (length == 1) {\r\n            ctx.fillStyle = \"black\";\r\n            ctx.fillRect(0, 0, 100, 175 * length);\r\n        }\r\n        else {\r\n            let gradient = ctx.createLinearGradient(0, 175 * length, 0, 0);\r\n            gradient.addColorStop(0, \"rgba(0,0,0,1)\");\r\n            gradient.addColorStop(1 / (length - 0.5), \"rgba(156,117,83,1)\");\r\n            ctx.fillStyle = gradient;\r\n            ctx.fillRect(0, 0, 100, 175 * length);\r\n            ctx.strokeStyle = \"white\";\r\n            ctx.lineWidth = 2;\r\n            ctx.beginPath();\r\n            ctx.moveTo(50, 175 * length - 70);\r\n            ctx.arc(50, 175 * length - 50, 20, 3 * Math.PI / 2, 3 * Math.PI / 2 + Math.PI * 2);\r\n            ctx.lineTo(50, 50);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n            if (holdProgress > 0) {\r\n                const holdSegments = holdProgress * length;\r\n                const progPt = Math.max(175 * length * (1 - holdProgress), 50);\r\n                ctx.fillStyle = `hsla(45, 100%, 70%, ${Math.min(holdSegments, 1.0)})`;\r\n                ctx.beginPath();\r\n                ctx.moveTo(0, 175 * length);\r\n                ctx.lineTo(100, 175 * length);\r\n                ctx.lineTo(100, progPt);\r\n                ctx.arc(50, progPt, 50, Math.PI, Math.PI * 2);\r\n                ctx.lineTo(0, progPt);\r\n                ctx.closePath();\r\n                ctx.fill();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Draw the background. The size is limited to 100x100\r\n     * @param ctx The canvas context\r\n     */\r\n    drawBackground(ctx) {\r\n        let gradient = ctx.createLinearGradient(0, 0, 0, 100);\r\n        gradient.addColorStop(0, \"rgba(255,212,212,1)\");\r\n        gradient.addColorStop(1, \"rgba(201,217,255,1)\");\r\n        ctx.fillStyle = gradient;\r\n        ctx.fillRect(0, 0, 100, 100);\r\n    }\r\n    /**\r\n     * Draw the bar line with width = 100pt and center is located at ``y = 0``\r\n     * @param ctx The canvas context\r\n     */\r\n    drawBarLine(ctx) {\r\n        ctx.fillStyle = \"#0000000e\";\r\n        ctx.fillRect(0, -0.1, 100, 0.2);\r\n    }\r\n    /** Draw the lane seperator with height = 100pt and center is located at ``x = 0`` */\r\n    drawLaneSeperator(ctx) {\r\n        ctx.fillStyle = \"#0000000e\";\r\n        ctx.fillRect(-0.1, 0, 0.2, 100);\r\n    }\r\n}\r\nexports.Skin = Skin;\r\nclass DefaultSkin extends Skin {\r\n}\r\nexports.DefaultSkin = DefaultSkin;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/Skin.ts?");

/***/ }),

/***/ "./src/ui/screens/EditScreen.ts":
/*!**************************************!*\
  !*** ./src/ui/screens/EditScreen.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EditOptionsScreen = exports.EditScreen = void 0;\r\nconst __1 = __webpack_require__(/*! ../.. */ \"./src/index.ts\");\r\nconst AudioManager_1 = __webpack_require__(/*! ../../audio/AudioManager */ \"./src/audio/AudioManager.ts\");\r\nconst Files_1 = __webpack_require__(/*! ../../Files */ \"./src/Files.ts\");\r\nconst BackButton_1 = __webpack_require__(/*! ../BackButton */ \"./src/ui/BackButton.ts\");\r\nconst QuickElement_1 = __webpack_require__(/*! ../QuickElement */ \"./src/ui/QuickElement.ts\");\r\nconst Screen_1 = __webpack_require__(/*! ../Screen */ \"./src/ui/Screen.ts\");\r\nconst PlayfieldScreen_1 = __webpack_require__(/*! ./PlayfieldScreen */ \"./src/ui/screens/PlayfieldScreen.ts\");\r\nconst SELECTED_INSET = 4;\r\nconst LONG_TAP_MS = 500;\r\nclass EditScreen extends Screen_1.Screen {\r\n    map;\r\n    hideBack = true;\r\n    title;\r\n    canvas;\r\n    ctx;\r\n    pianoContainer;\r\n    scroll = 0;\r\n    smoothScrollTo = 0;\r\n    selectedNotes = [];\r\n    get selectedNote() { return this.selectedNotes[0]; }\r\n    set selectedNote(v) { this.selectedNotes = [v]; }\r\n    ghostNote;\r\n    targetNote;\r\n    constructor(map) {\r\n        super();\r\n        this.map = map;\r\n        this.contents.className = \"editor\";\r\n        let titleBar = document.createElement(\"div\");\r\n        titleBar.className = \"titlebar\";\r\n        let topBackButton = document.createElement(\"div\");\r\n        topBackButton.className = \"back\";\r\n        this.title = document.createElement(\"div\");\r\n        this.title.className = \"title\";\r\n        this.title.textContent = map.title;\r\n        let optionsButton = document.createElement(\"div\");\r\n        optionsButton.className = \"options\";\r\n        optionsButton.textContent = \"Options\";\r\n        titleBar.append(topBackButton, this.title, optionsButton);\r\n        this.canvas = document.createElement(\"canvas\");\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n        this.pianoContainer = document.createElement(\"div\");\r\n        this.pianoContainer.className = \"piano\";\r\n        this.constructPiano();\r\n        let observer = new ResizeObserver(() => { this.renderCanvas(); });\r\n        observer.observe(this.canvas);\r\n        this.contents.append(titleBar, this.canvas, this.pianoContainer);\r\n        topBackButton.addEventListener(\"click\", () => {\r\n            Screen_1.Screen.pop();\r\n            if (Screen_1.Screen.getStack().length > 1)\r\n                BackButton_1.BACK_BUTTON.show();\r\n            __1.mapStore.putMap(map);\r\n        });\r\n        optionsButton.addEventListener(\"click\", () => {\r\n            let screen = new EditOptionsScreen(this);\r\n            screen.push();\r\n            BackButton_1.BACK_BUTTON.show();\r\n        });\r\n        this.canvas.addEventListener(\"pointerdown\", eventDown => {\r\n            const rect = this.canvas.getBoundingClientRect();\r\n            const ptWidth = this.canvas.offsetWidth;\r\n            const ptHeight = this.canvas.offsetHeight;\r\n            const noteWidth = ptWidth / 4;\r\n            const noteHeight = noteWidth * 1.75;\r\n            const interactedLane = Math.floor(eventDown.pageX / noteWidth);\r\n            const interactedOffset = (ptHeight - eventDown.pageY + rect.y) / noteHeight + this.scroll;\r\n            const oldScroll = this.scroll;\r\n            let scrollLock = true;\r\n            let smoothScrollVelocity = 0;\r\n            let longTap = false;\r\n            let longTapOldDuration = -1;\r\n            let longTapTask = setTimeout(() => {\r\n                longTap = true;\r\n                this.ghostNote = undefined;\r\n                console.log(\"long tap detected\");\r\n                navigator.vibrate([20]);\r\n                this.targetNote = this.map.notes.find(v => v.index == interactedLane &&\r\n                    interactedOffset >= v.offset &&\r\n                    interactedOffset < (v.offset + (v.duration ?? 1)));\r\n                if (!this.targetNote)\r\n                    this.ghostNote = {\r\n                        index: interactedLane,\r\n                        offset: Math.floor(interactedOffset),\r\n                        midi: this.getSelectedMIDINotes(),\r\n                        duration: 1\r\n                    };\r\n                else {\r\n                    longTapOldDuration = this.targetNote.duration || 1;\r\n                }\r\n                this.renderCanvas();\r\n            }, LONG_TAP_MS);\r\n            let pointerMove = (eventMove) => {\r\n                if (!scrollLock) {\r\n                    if (longTap) {\r\n                        const yIncreasement = (ptHeight - eventMove.pageY + rect.y) / noteHeight + this.scroll - interactedOffset;\r\n                        if (this.targetNote)\r\n                            this.targetNote.duration = Math.max(Math.round(longTapOldDuration + yIncreasement), 1);\r\n                        else\r\n                            this.ghostNote.duration = Math.max(Math.round(1 + yIncreasement), 1);\r\n                        this.renderCanvas();\r\n                        return;\r\n                    }\r\n                    smoothScrollVelocity = eventMove.movementY;\r\n                    this.scroll = Math.max(oldScroll + (eventMove.pageY - eventDown.pageY) / noteHeight, 0);\r\n                    this.renderCanvas();\r\n                    return;\r\n                }\r\n                const offDistance = Math.sqrt((eventMove.offsetX - eventDown.offsetX) ** 2 + (eventMove.offsetY - eventDown.offsetY) ** 2);\r\n                if (offDistance > 7.0) {\r\n                    scrollLock = false;\r\n                    clearTimeout(longTapTask);\r\n                    return;\r\n                }\r\n            };\r\n            let pointerUp = (eventUp) => {\r\n                document.removeEventListener(\"pointermove\", pointerMove);\r\n                document.removeEventListener(\"pointerup\", pointerUp);\r\n                clearTimeout(longTapTask);\r\n                const ptWidth = this.canvas.offsetWidth;\r\n                const ptHeight = this.canvas.offsetHeight;\r\n                const noteWidth = ptWidth / 4;\r\n                const noteHeight = noteWidth * 1.75;\r\n                if (this.ghostNote) {\r\n                    this.map.notes.push(this.ghostNote);\r\n                    this.map.notes.sort((a, b) => a.offset - b.offset);\r\n                }\r\n                else if (!scrollLock) { /* TODO: Implement smooth scroll here */ }\r\n                else {\r\n                    const note = this.map.notes.find(v => v.index == interactedLane &&\r\n                        interactedOffset >= v.offset &&\r\n                        interactedOffset < (v.offset + (v.duration ?? 1)));\r\n                    if (note) {\r\n                        if (longTap)\r\n                            this.map.notes.splice(this.map.notes.indexOf(note), 1);\r\n                        else {\r\n                            this.selectedNote = note;\r\n                            this.applySelectedMIDINotes(note.midi);\r\n                        }\r\n                    }\r\n                    else if (this.selectedNote)\r\n                        this.selectedNotes = [];\r\n                    else {\r\n                        let note = {\r\n                            index: interactedLane,\r\n                            offset: Math.floor(interactedOffset),\r\n                            midi: this.getSelectedMIDINotes(),\r\n                            duration: 1\r\n                        };\r\n                        this.map.notes.push(note);\r\n                        this.map.notes.sort((a, b) => a.offset - b.offset);\r\n                    }\r\n                }\r\n                this.ghostNote = undefined;\r\n                this.renderCanvas();\r\n            };\r\n            document.addEventListener(\"pointermove\", pointerMove);\r\n            document.addEventListener(\"pointerup\", pointerUp);\r\n        });\r\n        console.log(this);\r\n    }\r\n    constructPiano() {\r\n        const NOTES_NAMING = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\r\n        const BEGIN_OFFSET = 9;\r\n        let whiteNoteIndex = 0;\r\n        let appendLater = [];\r\n        for (let note = 0; note < 88; note++) {\r\n            // IMPORTANT: A0 starts from 21, C1 starts from 24\r\n            const noteName = NOTES_NAMING[(BEGIN_OFFSET + note) % NOTES_NAMING.length];\r\n            let e = document.createElement(\"div\");\r\n            e.id = `${21 + note}`;\r\n            if (noteName == \"C\")\r\n                e.textContent = `${Math.floor((BEGIN_OFFSET + note) / NOTES_NAMING.length)}`;\r\n            e.style.setProperty(\"--note-offset\", `${whiteNoteIndex}`);\r\n            e.className = \"note\";\r\n            if (noteName.includes(\"#\")) {\r\n                e.classList.add(\"sharp\");\r\n                appendLater.push(e);\r\n            }\r\n            else {\r\n                whiteNoteIndex++;\r\n                this.pianoContainer.appendChild(e);\r\n            }\r\n            e.addEventListener(\"click\", () => {\r\n                if (e.classList.contains(\"selected\")) {\r\n                    e.classList.remove(\"selected\");\r\n                    this.selectedNotes.forEach(inf => {\r\n                        const idx = inf.midi.findIndex(v => v.index == (21 + note));\r\n                        if (idx != -1)\r\n                            inf.midi.splice(idx, 1);\r\n                    });\r\n                }\r\n                else {\r\n                    e.classList.add(\"selected\");\r\n                    AudioManager_1.AudioManager.noteAt(note + 21, 0, 1);\r\n                    this.selectedNotes.forEach(inf => {\r\n                        const idx = inf.midi.findIndex(v => v.index == (21 + note));\r\n                        if (idx == -1)\r\n                            inf.midi.push({ index: (21 + note), velocity: 1.0 });\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        appendLater.forEach(n => this.pianoContainer.appendChild(n));\r\n    }\r\n    applySelectedMIDINotes(midi) {\r\n        for (let i = 0; i < this.pianoContainer.children.length; i++) {\r\n            const e = this.pianoContainer.children.item(i);\r\n            const related = midi.find(v => v.index == parseInt(e.id));\r\n            e.classList.remove(\"selected\");\r\n            if (related)\r\n                e.classList.add(\"selected\");\r\n        }\r\n    }\r\n    getSelectedMIDINotes() {\r\n        let list = [];\r\n        for (let i = 0; i < this.pianoContainer.children.length; i++) {\r\n            const e = this.pianoContainer.children.item(i);\r\n            if (e.classList.contains(\"selected\"))\r\n                list.push({ index: parseInt(e.id), velocity: 1.0 });\r\n        }\r\n        return list;\r\n    }\r\n    renderCanvas() {\r\n        const pxWidth = Math.floor(this.canvas.offsetWidth * devicePixelRatio);\r\n        const pxHeight = Math.floor(this.canvas.offsetHeight * devicePixelRatio);\r\n        if (this.canvas.width != pxWidth || this.canvas.height != pxHeight) {\r\n            this.canvas.width = pxWidth;\r\n            this.canvas.height = pxHeight;\r\n        }\r\n        const ptWidth = this.canvas.offsetWidth;\r\n        const ptHeight = this.canvas.offsetHeight;\r\n        this.ctx.clearRect(0, 0, pxWidth, pxHeight);\r\n        this.ctx.scale(devicePixelRatio, devicePixelRatio);\r\n        // We're now in pt coord space\r\n        const noteWidth = ptWidth / 4;\r\n        const noteHeight = noteWidth * 1.75;\r\n        // Render grid\r\n        this.ctx.strokeStyle = \"#0000002e\";\r\n        this.ctx.lineWidth = 2;\r\n        const topOffset = 1 - (this.scroll % 1);\r\n        const barLinesCount = Math.floor(ptHeight / noteHeight) + 1;\r\n        for (let i = 0; i < barLinesCount; i++) {\r\n            const barLineY = ptHeight - (topOffset + i) * noteHeight;\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(0, barLineY);\r\n            this.ctx.lineTo(ptWidth, barLineY);\r\n            this.ctx.closePath();\r\n            this.ctx.stroke();\r\n        }\r\n        for (let i = 1; i < 4; i++) {\r\n            const lX = noteWidth * i;\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(lX, 0);\r\n            this.ctx.lineTo(lX, ptHeight);\r\n            this.ctx.closePath();\r\n            this.ctx.stroke();\r\n        }\r\n        // Render notes\r\n        let renderNote = (note) => {\r\n            const noteDuration = Math.max(note.duration || 1, 1);\r\n            const noteY = ptHeight - (note.offset + noteDuration - this.scroll) * noteHeight;\r\n            if (noteY > ptHeight)\r\n                return false;\r\n            if (noteY + noteHeight * noteDuration < 0)\r\n                return true;\r\n            const isSelected = this.selectedNotes.includes(note);\r\n            if (noteDuration == 1)\r\n                this.ctx.fillStyle = \"rgba(0, 0, 0, 0.8)\";\r\n            else {\r\n                let gradient = this.ctx.createLinearGradient(0, noteY + 175 * noteDuration, 0, noteY);\r\n                gradient.addColorStop(0, \"rgba(0,0,0,0.8)\");\r\n                gradient.addColorStop(1 / (noteDuration - 0.5), \"rgba(156,117,83,0.8)\");\r\n                this.ctx.fillStyle = gradient;\r\n            }\r\n            this.ctx.fillRect(note.index * noteWidth, noteY, noteWidth, noteHeight * noteDuration);\r\n            let arcAt = (x, y, r, start = 0, end = Math.PI * 2) => {\r\n                this.ctx.beginPath();\r\n                this.ctx.moveTo(x + r, y);\r\n                this.ctx.arc(x, y, r, start, end);\r\n                this.ctx.closePath();\r\n            };\r\n            // Guide\r\n            this.ctx.fillStyle = isSelected ? \"#FF8A00\" : \"#ffffff\";\r\n            if (noteDuration > 1) {\r\n                let fillHold = (rad) => {\r\n                    this.ctx.beginPath();\r\n                    this.ctx.moveTo((note.index + 0.5) * noteWidth + rad, noteY + noteHeight / 2);\r\n                    this.ctx.arc((note.index + 0.5) * noteWidth, noteY + noteHeight / 2, rad, Math.PI, Math.PI * 2);\r\n                    this.ctx.lineTo((note.index + 0.5) * noteWidth - rad, noteY + noteHeight / 2);\r\n                    this.ctx.lineTo((note.index + 0.5) * noteWidth - rad, noteY + noteHeight * (noteDuration - 0.5));\r\n                    this.ctx.lineTo((note.index + 0.5) * noteWidth + rad, noteY + noteHeight * (noteDuration - 0.5));\r\n                    this.ctx.moveTo((note.index + 0.5) * noteWidth, noteY + noteHeight * (noteDuration - 0.5));\r\n                    this.ctx.arc((note.index + 0.5) * noteWidth, noteY + noteHeight * (noteDuration - 0.5), rad, 0, Math.PI);\r\n                    this.ctx.closePath();\r\n                    this.ctx.fill();\r\n                };\r\n                fillHold(noteWidth / 4);\r\n                if (isSelected) {\r\n                    this.ctx.fillStyle = \"#FFB258\";\r\n                    fillHold(noteWidth / 4 - SELECTED_INSET);\r\n                }\r\n            }\r\n            else {\r\n                arcAt((note.index + 0.5) * noteWidth, noteY + noteHeight / 2, noteWidth / 4);\r\n                this.ctx.fill();\r\n                if (isSelected) {\r\n                    this.ctx.fillStyle = \"#FFB258\";\r\n                    arcAt((note.index + 0.5) * noteWidth, noteY + noteHeight / 2, noteWidth / 4 - SELECTED_INSET);\r\n                    this.ctx.fill();\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        for (let i = 0; i < this.map.notes.length; i++)\r\n            if (renderNote(this.map.notes[i]))\r\n                break;\r\n        if (this.ghostNote) {\r\n            this.ctx.globalAlpha = 0.5;\r\n            renderNote(this.ghostNote);\r\n            this.ctx.globalAlpha = 1;\r\n        }\r\n        this.ctx.resetTransform();\r\n        // We're now in px coord space\r\n    }\r\n}\r\nexports.EditScreen = EditScreen;\r\nclass EditOptionsScreen extends Screen_1.Screen {\r\n    editor;\r\n    constructor(editor) {\r\n        super();\r\n        this.editor = editor;\r\n        let listing = document.createElement(\"div\");\r\n        listing.className = \"listing\";\r\n        let testButton;\r\n        let setTitleButton;\r\n        let setMapperButton;\r\n        let setSpeedButton;\r\n        let setAccelButton;\r\n        let exportButton;\r\n        listing.append(testButton = QuickElement_1.QuickElement.header(\"Test\", \"Open the player so you can test it\", true), setTitleButton = QuickElement_1.QuickElement.header(\"Set Title\", \"Set the song title\", true), setMapperButton = QuickElement_1.QuickElement.header(\"Set Mapper\", \"Set the mapper so everyone can find you\", true), setSpeedButton = QuickElement_1.QuickElement.header(\"Set Speed\", \"Set initial speed (notes/s)\", true), setAccelButton = QuickElement_1.QuickElement.header(\"Set Acceleration\", \"Set speed acceleration (notes/s^2)\", true), exportButton = QuickElement_1.QuickElement.header(\"Export JSON\", \"Export as JSON\", true));\r\n        testButton.addEventListener(\"click\", () => {\r\n            let screen = new PlayfieldScreen_1.PlayfieldScreen(editor.map);\r\n            screen.push();\r\n            BackButton_1.BACK_BUTTON.hide();\r\n        });\r\n        setTitleButton.addEventListener(\"click\", () => {\r\n            this.editor.map.title = prompt(\"Type the title:\", this.editor.map.title);\r\n            this.editor.title.textContent = this.editor.map.title;\r\n        });\r\n        setMapperButton.addEventListener(\"click\", () => { this.editor.map.author = prompt(\"Type the mapper's name:\", this.editor.map.author); });\r\n        setSpeedButton.addEventListener(\"click\", () => { this.editor.map.initialSpeed = parseFloat(prompt(\"Type the initial speed (notes/s):\", `${this.editor.map.initialSpeed}`)); });\r\n        setAccelButton.addEventListener(\"click\", () => { this.editor.map.scrollAcceleration = parseFloat(prompt(\"Type the acceleration (notes/s^2):\", `${this.editor.map.scrollAcceleration}`)); });\r\n        exportButton.addEventListener(\"click\", () => {\r\n            Files_1.Files.downloadJSON(editor.map, `${editor.map.title} (${editor.map.author}).json`);\r\n        });\r\n        this.contents.append(QuickElement_1.QuickElement.header(\"Edit Options\", \"Select an option or go back\"), listing);\r\n    }\r\n}\r\nexports.EditOptionsScreen = EditOptionsScreen;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/screens/EditScreen.ts?");

/***/ }),

/***/ "./src/ui/screens/HomeScreen.ts":
/*!**************************************!*\
  !*** ./src/ui/screens/HomeScreen.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.HomeScreen = void 0;\r\nconst __1 = __webpack_require__(/*! ../.. */ \"./src/index.ts\");\r\nconst MIDIConverter_1 = __webpack_require__(/*! ../../conversion/MIDIConverter */ \"./src/conversion/MIDIConverter.ts\");\r\nconst Files_1 = __webpack_require__(/*! ../../Files */ \"./src/Files.ts\");\r\nconst BackButton_1 = __webpack_require__(/*! ../BackButton */ \"./src/ui/BackButton.ts\");\r\nconst QuickElement_1 = __webpack_require__(/*! ../QuickElement */ \"./src/ui/QuickElement.ts\");\r\nconst Screen_1 = __webpack_require__(/*! ../Screen */ \"./src/ui/Screen.ts\");\r\nconst EditScreen_1 = __webpack_require__(/*! ./EditScreen */ \"./src/ui/screens/EditScreen.ts\");\r\nconst ListingScreen_1 = __webpack_require__(/*! ./ListingScreen */ \"./src/ui/screens/ListingScreen.ts\");\r\nconst MapInfoScreen_1 = __webpack_require__(/*! ./MapInfoScreen */ \"./src/ui/screens/MapInfoScreen.ts\");\r\nclass HomeScreen extends Screen_1.Screen {\r\n    constructor() {\r\n        super();\r\n        let listing = document.createElement(\"div\");\r\n        listing.className = \"listing\";\r\n        listing.style.overflow = \"hidden\";\r\n        let browse;\r\n        let newButton;\r\n        let importMIDI;\r\n        let importJSON;\r\n        listing.append(browse = QuickElement_1.QuickElement.header(\"Browse\", \"Browse imported songs\", true), newButton = QuickElement_1.QuickElement.header(\"New\", \"Create new song from nothing\", true), importMIDI = QuickElement_1.QuickElement.header(\"Import MIDI\", \"Import MIDI file\", true), importJSON = QuickElement_1.QuickElement.header(\"Import JSON\", \"Import JSON map\", true));\r\n        browse.addEventListener(\"click\", () => {\r\n            let screen = new ListingScreen_1.ListingScreen(__1.mapStore);\r\n            screen.push();\r\n            BackButton_1.BACK_BUTTON.show();\r\n        });\r\n        newButton.addEventListener(\"click\", () => {\r\n            let screen = new EditScreen_1.EditScreen({\r\n                title: \"Untitled\",\r\n                author: \"<Your name here>\",\r\n                initialSpeed: 1.8,\r\n                scrollAcceleration: 0.01,\r\n                notes: [\r\n                    { offset: 0, index: 0, midi: [] },\r\n                    { offset: 1, index: 1, midi: [] },\r\n                    { offset: 2, index: 2, midi: [] },\r\n                    { offset: 3, index: 3, duration: 2, midi: [] }\r\n                ],\r\n                id: \"customsong-\" + Math.random().toString()\r\n            });\r\n            screen.push();\r\n        });\r\n        importMIDI.addEventListener(\"click\", async () => {\r\n            let files = await Files_1.Files.requestUpload([\"audio/midi\"]);\r\n            let lastMap;\r\n            for (let i = 0; i < files.length; i++) {\r\n                const file = files.item(i);\r\n                const info = {\r\n                    title: file.name,\r\n                    author: \"Autoconverter (MIDI)\",\r\n                    initialSpeed: 1.8,\r\n                    scrollAcceleration: 0.01,\r\n                    id: file.name + \"-\" + Math.random()\r\n                };\r\n                const map = MIDIConverter_1.MIDIConverter.convertFromRaw(info, await file.arrayBuffer());\r\n                await __1.mapStore.putMap(map);\r\n                lastMap = map;\r\n            }\r\n            if (lastMap) {\r\n                let screen = new MapInfoScreen_1.MapInfoScreen(lastMap);\r\n                screen.push();\r\n                BackButton_1.BACK_BUTTON.show();\r\n            }\r\n        });\r\n        importJSON.addEventListener(\"click\", async () => {\r\n            let files = await Files_1.Files.requestUpload([\"application/json\"]);\r\n            let lastMap;\r\n            for (let i = 0; i < files.length; i++) {\r\n                const file = files.item(i);\r\n                const map = JSON.parse(await file.text());\r\n                await __1.mapStore.putMap(map);\r\n                lastMap = map;\r\n            }\r\n            if (lastMap) {\r\n                let screen = new MapInfoScreen_1.MapInfoScreen(lastMap);\r\n                screen.push();\r\n                BackButton_1.BACK_BUTTON.show();\r\n            }\r\n        });\r\n        this.contents.append(QuickElement_1.QuickElement.header(\"Welcome!\", \"What do you want?\"), listing);\r\n    }\r\n}\r\nexports.HomeScreen = HomeScreen;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/screens/HomeScreen.ts?");

/***/ }),

/***/ "./src/ui/screens/ListingScreen.ts":
/*!*****************************************!*\
  !*** ./src/ui/screens/ListingScreen.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ListingScreen = void 0;\r\nconst QuickElement_1 = __webpack_require__(/*! ../QuickElement */ \"./src/ui/QuickElement.ts\");\r\nconst Screen_1 = __webpack_require__(/*! ../Screen */ \"./src/ui/Screen.ts\");\r\nconst MapInfoScreen_1 = __webpack_require__(/*! ./MapInfoScreen */ \"./src/ui/screens/MapInfoScreen.ts\");\r\nclass ListingScreen extends Screen_1.Screen {\r\n    store;\r\n    header;\r\n    listingView;\r\n    uploadMIDIButton;\r\n    newMapButton;\r\n    constructor(store) {\r\n        super();\r\n        this.store = store;\r\n        this.header = QuickElement_1.QuickElement.header(\"Songs Listing\", \"Play any song you want!\");\r\n        this.header.classList.add(\"songslisting\");\r\n        this.listingView = document.createElement(\"div\");\r\n        this.listingView.className = \"listing\";\r\n        this.contents.append(this.header, this.listingView);\r\n        this.applyQuery();\r\n    }\r\n    async applyQuery(query = {}) {\r\n        while (this.listingView.firstChild)\r\n            this.listingView.firstChild.remove();\r\n        let maps = await this.store.queryMaps(query);\r\n        maps.forEach(mapInfo => {\r\n            let inf = QuickElement_1.QuickElement.header(mapInfo.title, `Mapped by ${mapInfo.author}`, true);\r\n            this.listingView.append(inf);\r\n            inf.addEventListener(\"click\", async () => {\r\n                const map = await this.store.getMap(mapInfo);\r\n                if (!map)\r\n                    return;\r\n                let screen = new MapInfoScreen_1.MapInfoScreen(map);\r\n                screen.push();\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.ListingScreen = ListingScreen;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/screens/ListingScreen.ts?");

/***/ }),

/***/ "./src/ui/screens/MapInfoScreen.ts":
/*!*****************************************!*\
  !*** ./src/ui/screens/MapInfoScreen.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.MapInfoScreen = void 0;\r\nconst __1 = __webpack_require__(/*! ../.. */ \"./src/index.ts\");\r\nconst Files_1 = __webpack_require__(/*! ../../Files */ \"./src/Files.ts\");\r\nconst BackButton_1 = __webpack_require__(/*! ../BackButton */ \"./src/ui/BackButton.ts\");\r\nconst QuickElement_1 = __webpack_require__(/*! ../QuickElement */ \"./src/ui/QuickElement.ts\");\r\nconst Screen_1 = __webpack_require__(/*! ../Screen */ \"./src/ui/Screen.ts\");\r\nconst EditScreen_1 = __webpack_require__(/*! ./EditScreen */ \"./src/ui/screens/EditScreen.ts\");\r\nconst ListingScreen_1 = __webpack_require__(/*! ./ListingScreen */ \"./src/ui/screens/ListingScreen.ts\");\r\nconst ModifiersScreen_1 = __webpack_require__(/*! ./ModifiersScreen */ \"./src/ui/screens/ModifiersScreen.ts\");\r\nconst PlayfieldScreen_1 = __webpack_require__(/*! ./PlayfieldScreen */ \"./src/ui/screens/PlayfieldScreen.ts\");\r\nclass MapInfoScreen extends Screen_1.Screen {\r\n    map;\r\n    metadata;\r\n    diffView;\r\n    speedView;\r\n    modifiers = [];\r\n    constructor(map) {\r\n        super();\r\n        this.map = map;\r\n        this.metadata = QuickElement_1.QuickElement.header(map.title, `Mapped by ${map.author}`);\r\n        this.diffView = document.createElement(\"div\");\r\n        this.diffView.className = \"diff\";\r\n        this.speedView = document.createElement(\"div\");\r\n        this.speedView.className = \"speed\";\r\n        this.speedView.textContent = `${map.initialSpeed.toFixed(1)} n/s +${map.scrollAcceleration.toFixed(2)}/s`;\r\n        this.diffView.appendChild(this.speedView);\r\n        let listing = document.createElement(\"div\");\r\n        listing.className = \"listing\";\r\n        listing.style.overflow = \"hidden\";\r\n        let playButton;\r\n        let modifiersButton;\r\n        let editButton;\r\n        let exportButton;\r\n        let deleteButton;\r\n        listing.append(playButton = QuickElement_1.QuickElement.header(\"Start\", \"Play this map\", true), modifiersButton = QuickElement_1.QuickElement.header(\"Modifiers\", \"Apply modifiers\", true), editButton = QuickElement_1.QuickElement.header(\"Edit\", \"Edit this map\", true), exportButton = QuickElement_1.QuickElement.header(\"Export JSON\", \"Export this map as JSON\", true), deleteButton = QuickElement_1.QuickElement.header(\"Delete\", \"Delete this map\", true));\r\n        this.contents.append(this.metadata, this.diffView, listing);\r\n        playButton.addEventListener(\"click\", () => {\r\n            BackButton_1.BACK_BUTTON.hide();\r\n            Screen_1.Screen.pop();\r\n            let playfieldScreen = new PlayfieldScreen_1.PlayfieldScreen(map, { modifiers: this.modifiers });\r\n            playfieldScreen.push();\r\n        });\r\n        modifiersButton.addEventListener(\"click\", () => {\r\n            let screen = new ModifiersScreen_1.ModifiersScreen(this.modifiers);\r\n            screen.push();\r\n        });\r\n        editButton.addEventListener(\"click\", () => {\r\n            BackButton_1.BACK_BUTTON.hide();\r\n            Screen_1.Screen.pop();\r\n            Screen_1.Screen.pop();\r\n            let screen = new EditScreen_1.EditScreen(map);\r\n            screen.push();\r\n        });\r\n        exportButton.addEventListener(\"click\", () => {\r\n            Files_1.Files.downloadJSON(map, `${map.title} (${map.author}).json`);\r\n        });\r\n        deleteButton.addEventListener(\"click\", async () => {\r\n            if (!confirm(`Delete ${map.title} (mapped by ${map.author})? You can create backup by exporting it to JSON.`))\r\n                return;\r\n            await __1.mapStore.deleteMap(map);\r\n            Screen_1.Screen.pop();\r\n            let prevScreen = Screen_1.Screen.getStack().at(-1);\r\n            if (!prevScreen)\r\n                return;\r\n            if (prevScreen instanceof ListingScreen_1.ListingScreen) {\r\n                prevScreen.applyQuery({});\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.MapInfoScreen = MapInfoScreen;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/screens/MapInfoScreen.ts?");

/***/ }),

/***/ "./src/ui/screens/ModifiersScreen.ts":
/*!*******************************************!*\
  !*** ./src/ui/screens/ModifiersScreen.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModifiersScreen = void 0;\r\nconst Modifier_1 = __webpack_require__(/*! ../../engine/modifiers/Modifier */ \"./src/engine/modifiers/Modifier.ts\");\r\nconst QuickElement_1 = __webpack_require__(/*! ../QuickElement */ \"./src/ui/QuickElement.ts\");\r\nconst Screen_1 = __webpack_require__(/*! ../Screen */ \"./src/ui/Screen.ts\");\r\nclass ModifiersScreen extends Screen_1.Screen {\r\n    mods;\r\n    constructor(mods) {\r\n        super();\r\n        this.mods = mods;\r\n        let listing = document.createElement(\"div\");\r\n        listing.className = \"listing\";\r\n        Modifier_1.Modifier.modifiers.forEach(mod => {\r\n            let e = QuickElement_1.QuickElement.header(mod.name, mod.description, true);\r\n            if (mods.includes(mod))\r\n                e.classList.add(\"selected\");\r\n            e.style.setProperty(\"--selected-color\", mod.selectedColor);\r\n            listing.appendChild(e);\r\n            e.addEventListener(\"click\", () => {\r\n                const idx = mods.indexOf(mod);\r\n                if (idx != -1) {\r\n                    e.classList.remove(\"selected\");\r\n                    mods.splice(idx, 1);\r\n                }\r\n                else {\r\n                    e.classList.add(\"selected\");\r\n                    mods.push(mod);\r\n                }\r\n            });\r\n        });\r\n        this.contents.append(QuickElement_1.QuickElement.header(\"Modifiers\", \"Make your life easier or harder!\"), listing);\r\n    }\r\n}\r\nexports.ModifiersScreen = ModifiersScreen;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/screens/ModifiersScreen.ts?");

/***/ }),

/***/ "./src/ui/screens/PlayfieldScreen.ts":
/*!*******************************************!*\
  !*** ./src/ui/screens/PlayfieldScreen.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.PlayfieldScreen = void 0;\r\nconst BackButton_1 = __webpack_require__(/*! ../BackButton */ \"./src/ui/BackButton.ts\");\r\nconst Playfield_1 = __webpack_require__(/*! ../Playfield */ \"./src/ui/Playfield.ts\");\r\nconst Screen_1 = __webpack_require__(/*! ../Screen */ \"./src/ui/Screen.ts\");\r\nclass PlayfieldScreen extends Screen_1.Screen {\r\n    map;\r\n    options;\r\n    playfield;\r\n    constructor(map, options = {}) {\r\n        super();\r\n        this.map = map;\r\n        this.options = options;\r\n        this.playfield = new Playfield_1.Playfield(map, options);\r\n        this.contents.append(this.playfield.container);\r\n        this.playfield.failedCallback = async () => {\r\n            await new Promise(resolve => setTimeout(() => resolve(), 500));\r\n            Screen_1.Screen.pop();\r\n            if (Screen_1.Screen.getStack().length > 1)\r\n                BackButton_1.BACK_BUTTON.show();\r\n        };\r\n    }\r\n}\r\nexports.PlayfieldScreen = PlayfieldScreen;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/screens/PlayfieldScreen.ts?");

/***/ }),

/***/ "./node_modules/idb/build/index.js":
/*!*****************************************!*\
  !*** ./node_modules/idb/build/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unwrap\": () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   \"wrap\": () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   \"deleteDB\": () => (/* binding */ deleteDB),\n/* harmony export */   \"openDB\": () => (/* binding */ openDB)\n/* harmony export */ });\n/* harmony import */ var _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap-idb-value.js */ \"./node_modules/idb/build/wrap-idb-value.js\");\n\n\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade((0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.result), event.oldVersion, event.newVersion, (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\n(0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.r)((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\n\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./node_modules/idb/build/index.js?");

/***/ }),

/***/ "./node_modules/idb/build/wrap-idb-value.js":
/*!**************************************************!*\
  !*** ./node_modules/idb/build/wrap-idb-value.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"a\": () => (/* binding */ reverseTransformCache),\n/* harmony export */   \"i\": () => (/* binding */ instanceOfAny),\n/* harmony export */   \"r\": () => (/* binding */ replaceTraps),\n/* harmony export */   \"u\": () => (/* binding */ unwrap),\n/* harmony export */   \"w\": () => (/* binding */ wrap)\n/* harmony export */ });\nconst instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./node_modules/idb/build/wrap-idb-value.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;