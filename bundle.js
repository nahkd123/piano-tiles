/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/midi-player-js/build/index.browser.js":
/*!************************************************************!*\
  !*** ./node_modules/midi-player-js/build/index.browser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * Constants used in player.\n */\nvar Constants = {\n  VERSION: '2.0.16',\n  NOTES: [],\n  HEADER_CHUNK_LENGTH: 14,\n  CIRCLE_OF_FOURTHS: ['C', 'F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb', 'Fb', 'Bbb', 'Ebb', 'Abb'],\n  CIRCLE_OF_FIFTHS: ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#']\n}; // Builds notes object for reference against binary values.\n\nvar allNotes = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']];\nvar counter = 0; // All available octaves.\n\nvar _loop = function _loop(i) {\n  allNotes.forEach(function (noteGroup) {\n    noteGroup.forEach(function (note) {\n      return Constants.NOTES[counter] = note + i;\n    });\n    counter++;\n  });\n};\n\nfor (var i = -1; i <= 9; i++) {\n  _loop(i);\n}\n\n/**\n * Contains misc static utility methods.\n */\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {\n    _classCallCheck(this, Utils);\n  }\n\n  _createClass(Utils, null, [{\n    key: \"byteToHex\",\n    value:\n    /**\n     * Converts a single byte to a hex string.\n     * @param {number} byte\n     * @return {string}\n     */\n    function byteToHex(_byte) {\n      // Ensure hex string always has two chars\n      return ('0' + _byte.toString(16)).slice(-2);\n    }\n    /**\n     * Converts an array of bytes to a hex string.\n     * @param {array} byteArray\n     * @return {string}\n     */\n\n  }, {\n    key: \"bytesToHex\",\n    value: function bytesToHex(byteArray) {\n      var hex = [];\n      byteArray.forEach(function (_byte2) {\n        return hex.push(Utils.byteToHex(_byte2));\n      });\n      return hex.join('');\n    }\n    /**\n     * Converts a hex string to a number.\n     * @param {string} hexString\n     * @return {number}\n     */\n\n  }, {\n    key: \"hexToNumber\",\n    value: function hexToNumber(hexString) {\n      return parseInt(hexString, 16);\n    }\n    /**\n     * Converts an array of bytes to a number.\n     * @param {array} byteArray\n     * @return {number}\n     */\n\n  }, {\n    key: \"bytesToNumber\",\n    value: function bytesToNumber(byteArray) {\n      return Utils.hexToNumber(Utils.bytesToHex(byteArray));\n    }\n    /**\n     * Converts an array of bytes to letters.\n     * @param {array} byteArray\n     * @return {string}\n     */\n\n  }, {\n    key: \"bytesToLetters\",\n    value: function bytesToLetters(byteArray) {\n      var letters = [];\n      byteArray.forEach(function (_byte3) {\n        return letters.push(String.fromCharCode(_byte3));\n      });\n      return letters.join('');\n    }\n    /**\n     * Converts a decimal to it's binary representation.\n     * @param {number} dec\n     * @return {string}\n     */\n\n  }, {\n    key: \"decToBinary\",\n    value: function decToBinary(dec) {\n      return (dec >>> 0).toString(2);\n    }\n    /**\n     * Determines the length in bytes of a variable length quaantity.  The first byte in given range is assumed to be beginning of var length quantity.\n     * @param {array} byteArray\n     * @return {number}\n     */\n\n  }, {\n    key: \"getVarIntLength\",\n    value: function getVarIntLength(byteArray) {\n      // Get byte count of delta VLV\n      // http://www.ccarh.org/courses/253/handout/vlv/\n      // If byte is greater or equal to 80h (128 decimal) then the next byte\n      // is also part of the VLV,\n      // else byte is the last byte in a VLV.\n      var currentByte = byteArray[0];\n      var byteCount = 1;\n\n      while (currentByte >= 128) {\n        currentByte = byteArray[byteCount];\n        byteCount++;\n      }\n\n      return byteCount;\n    }\n    /**\n     * Reads a variable length value.\n     * @param {array} byteArray\n     * @return {number}\n     */\n\n  }, {\n    key: \"readVarInt\",\n    value: function readVarInt(byteArray) {\n      var result = 0;\n      byteArray.forEach(function (number) {\n        var b = number;\n\n        if (b & 0x80) {\n          result += b & 0x7f;\n          result <<= 7;\n        } else {\n          /* b is the last byte */\n          result += b;\n        }\n      });\n      return result;\n    }\n    /**\n     * Decodes base-64 encoded string\n     * @param {string} string\n     * @return {string}\n     */\n\n  }, {\n    key: \"atob\",\n    value: function (_atob) {\n      function atob(_x) {\n        return _atob.apply(this, arguments);\n      }\n\n      atob.toString = function () {\n        return _atob.toString();\n      };\n\n      return atob;\n    }(function (string) {\n      if (typeof atob === 'function') return atob(string);\n      return Buffer.from(string, 'base64').toString('binary');\n    })\n  }]);\n\n  return Utils;\n}();\n\n/**\n * Class representing a track.  Contains methods for parsing events and keeping track of pointer.\n */\n\nvar Track = /*#__PURE__*/function () {\n  function Track(index, data) {\n    _classCallCheck(this, Track);\n\n    this.enabled = true;\n    this.eventIndex = 0;\n    this.pointer = 0;\n    this.lastTick = 0;\n    this.lastStatus = null;\n    this.index = index;\n    this.data = data;\n    this.delta = 0;\n    this.runningDelta = 0;\n    this.events = []; // Ensure last 3 bytes of track are End of Track event\n\n    var lastThreeBytes = this.data.subarray(this.data.length - 3, this.data.length);\n\n    if (!(lastThreeBytes[0] === 0xff && lastThreeBytes[1] === 0x2f && lastThreeBytes[2] === 0x00)) {\n      throw 'Invalid MIDI file; Last three bytes of track ' + this.index + 'must be FF 2F 00 to mark end of track';\n    }\n  }\n  /**\n   * Resets all stateful track informaion used during playback.\n   * @return {Track}\n   */\n\n\n  _createClass(Track, [{\n    key: \"reset\",\n    value: function reset() {\n      this.enabled = true;\n      this.eventIndex = 0;\n      this.pointer = 0;\n      this.lastTick = 0;\n      this.lastStatus = null;\n      this.delta = 0;\n      this.runningDelta = 0;\n      return this;\n    }\n    /**\n     * Sets this track to be enabled during playback.\n     * @return {Track}\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this.enabled = true;\n      return this;\n    }\n    /**\n     * Sets this track to be disabled during playback.\n     * @return {Track}\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n    /**\n     * Sets the track event index to the nearest event to the given tick.\n     * @param {number} tick\n     * @return {Track}\n     */\n\n  }, {\n    key: \"setEventIndexByTick\",\n    value: function setEventIndexByTick(tick) {\n      tick = tick || 0;\n\n      for (var i in this.events) {\n        if (this.events[i].tick >= tick) {\n          this.eventIndex = i;\n          return this;\n        }\n      }\n    }\n    /**\n     * Gets byte located at pointer position.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getCurrentByte\",\n    value: function getCurrentByte() {\n      return this.data[this.pointer];\n    }\n    /**\n     * Gets count of delta bytes and current pointer position.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getDeltaByteCount\",\n    value: function getDeltaByteCount() {\n      return Utils.getVarIntLength(this.data.subarray(this.pointer));\n    }\n    /**\n     * Get delta value at current pointer position.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getDelta\",\n    value: function getDelta() {\n      return Utils.readVarInt(this.data.subarray(this.pointer, this.pointer + this.getDeltaByteCount()));\n    }\n    /**\n     * Handles event within a given track starting at specified index\n     * @param {number} currentTick\n     * @param {boolean} dryRun - If true events will be parsed and returned regardless of time.\n     */\n\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(currentTick, dryRun) {\n      dryRun = dryRun || false;\n\n      if (dryRun) {\n        var elapsedTicks = currentTick - this.lastTick;\n        var delta = this.getDelta();\n        var eventReady = elapsedTicks >= delta;\n\n        if (this.pointer < this.data.length && (dryRun || eventReady)) {\n          var _event = this.parseEvent();\n\n          if (this.enabled) return _event; // Recursively call this function for each event ahead that has 0 delta time?\n        }\n      } else {\n        // Let's actually play the MIDI from the generated JSON events created by the dry run.\n        if (this.events[this.eventIndex] && this.events[this.eventIndex].tick <= currentTick) {\n          this.eventIndex++;\n          if (this.enabled) return this.events[this.eventIndex - 1];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Get string data from event.\n     * @param {number} eventStartIndex\n     * @return {string}\n     */\n\n  }, {\n    key: \"getStringData\",\n    value: function getStringData(eventStartIndex) {\n      var varIntLength = Utils.getVarIntLength(this.data.subarray(eventStartIndex + 2));\n      var varIntValue = Utils.readVarInt(this.data.subarray(eventStartIndex + 2, eventStartIndex + 2 + varIntLength));\n      var letters = Utils.bytesToLetters(this.data.subarray(eventStartIndex + 2 + varIntLength, eventStartIndex + 2 + varIntLength + varIntValue));\n      return letters;\n    }\n    /**\n     * Parses event into JSON and advances pointer for the track\n     * @return {object}\n     */\n\n  }, {\n    key: \"parseEvent\",\n    value: function parseEvent() {\n      var eventStartIndex = this.pointer + this.getDeltaByteCount();\n      var eventJson = {};\n      var deltaByteCount = this.getDeltaByteCount();\n      eventJson.track = this.index + 1;\n      eventJson.delta = this.getDelta();\n      this.lastTick = this.lastTick + eventJson.delta;\n      this.runningDelta += eventJson.delta;\n      eventJson.tick = this.runningDelta;\n      eventJson.byteIndex = this.pointer; //eventJson.raw = event;\n\n      if (this.data[eventStartIndex] == 0xff) {\n        // Meta Event\n        // If this is a meta event we should emit the data and immediately move to the next event\n        // otherwise if we let it run through the next cycle a slight delay will accumulate if multiple tracks\n        // are being played simultaneously\n        switch (this.data[eventStartIndex + 1]) {\n          case 0x00:\n            // Sequence Number\n            eventJson.name = 'Sequence Number';\n            break;\n\n          case 0x01:\n            // Text Event\n            eventJson.name = 'Text Event';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x02:\n            // Copyright Notice\n            eventJson.name = 'Copyright Notice';\n            break;\n\n          case 0x03:\n            // Sequence/Track Name\n            eventJson.name = 'Sequence/Track Name';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x04:\n            // Instrument Name\n            eventJson.name = 'Instrument Name';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x05:\n            // Lyric\n            eventJson.name = 'Lyric';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x06:\n            // Marker\n            eventJson.name = 'Marker';\n            break;\n\n          case 0x07:\n            // Cue Point\n            eventJson.name = 'Cue Point';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x09:\n            // Device Name\n            eventJson.name = 'Device Name';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x20:\n            // MIDI Channel Prefix\n            eventJson.name = 'MIDI Channel Prefix';\n            break;\n\n          case 0x21:\n            // MIDI Port\n            eventJson.name = 'MIDI Port';\n            eventJson.data = Utils.bytesToNumber([this.data[eventStartIndex + 3]]);\n            break;\n\n          case 0x2F:\n            // End of Track\n            eventJson.name = 'End of Track';\n            break;\n\n          case 0x51:\n            // Set Tempo\n            eventJson.name = 'Set Tempo';\n            eventJson.data = Math.round(60000000 / Utils.bytesToNumber(this.data.subarray(eventStartIndex + 3, eventStartIndex + 6)));\n            this.tempo = eventJson.data;\n            break;\n\n          case 0x54:\n            // SMTPE Offset\n            eventJson.name = 'SMTPE Offset';\n            break;\n\n          case 0x58:\n            // Time Signature\n            // FF 58 04 nn dd cc bb\n            eventJson.name = 'Time Signature';\n            eventJson.data = this.data.subarray(eventStartIndex + 3, eventStartIndex + 7);\n            eventJson.timeSignature = \"\" + eventJson.data[0] + \"/\" + Math.pow(2, eventJson.data[1]);\n            break;\n\n          case 0x59:\n            // Key Signature\n            // FF 59 02 sf mi\n            eventJson.name = 'Key Signature';\n            eventJson.data = this.data.subarray(eventStartIndex + 3, eventStartIndex + 5);\n\n            if (eventJson.data[0] >= 0) {\n              eventJson.keySignature = Constants.CIRCLE_OF_FIFTHS[eventJson.data[0]];\n            } else if (eventJson.data[0] < 0) {\n              eventJson.keySignature = Constants.CIRCLE_OF_FOURTHS[Math.abs(eventJson.data[0])];\n            }\n\n            if (eventJson.data[1] == 0) {\n              eventJson.keySignature += \" Major\";\n            } else if (eventJson.data[1] == 1) {\n              eventJson.keySignature += \" Minor\";\n            }\n\n            break;\n\n          case 0x7F:\n            // Sequencer-Specific Meta-event\n            eventJson.name = 'Sequencer-Specific Meta-event';\n            break;\n\n          default:\n            eventJson.name = 'Unknown: ' + this.data[eventStartIndex + 1].toString(16);\n            break;\n        }\n\n        var varIntLength = Utils.getVarIntLength(this.data.subarray(eventStartIndex + 2));\n        var length = Utils.readVarInt(this.data.subarray(eventStartIndex + 2, eventStartIndex + 2 + varIntLength)); //console.log(eventJson);\n\n        this.pointer += deltaByteCount + 3 + length; //console.log(eventJson);\n      } else if (this.data[eventStartIndex] === 0xf0) {\n        // Sysex\n        eventJson.name = 'Sysex';\n        var varQuantityByteLength = Utils.getVarIntLength(this.data.subarray(eventStartIndex + 1));\n        var varQuantityByteValue = Utils.readVarInt(this.data.subarray(eventStartIndex + 1, eventStartIndex + 1 + varQuantityByteLength));\n        eventJson.data = this.data.subarray(eventStartIndex + 1 + varQuantityByteLength, eventStartIndex + 1 + varQuantityByteLength + varQuantityByteValue);\n        this.pointer += deltaByteCount + 1 + varQuantityByteLength + varQuantityByteValue;\n      } else if (this.data[eventStartIndex] === 0xf7) {\n        // Sysex (escape)\n        // http://www.somascape.org/midi/tech/mfile.html#sysex\n        eventJson.name = 'Sysex (escape)';\n\n        var _varQuantityByteLength = Utils.getVarIntLength(this.data.subarray(eventStartIndex + 1));\n\n        var _varQuantityByteValue = Utils.readVarInt(this.data.subarray(eventStartIndex + 1, eventStartIndex + 1 + _varQuantityByteLength));\n\n        eventJson.data = this.data.subarray(eventStartIndex + 1 + _varQuantityByteLength, eventStartIndex + 1 + _varQuantityByteLength + _varQuantityByteValue);\n        this.pointer += deltaByteCount + 1 + _varQuantityByteLength + _varQuantityByteValue;\n      } else {\n        // Voice event\n        if (this.data[eventStartIndex] < 0x80) {\n          // Running status\n          eventJson.running = true;\n          eventJson.noteNumber = this.data[eventStartIndex];\n          eventJson.noteName = Constants.NOTES[this.data[eventStartIndex]];\n          eventJson.velocity = this.data[eventStartIndex + 1];\n\n          if (this.lastStatus <= 0x8f) {\n            eventJson.name = 'Note off';\n            eventJson.channel = this.lastStatus - 0x80 + 1;\n            this.pointer += deltaByteCount + 2;\n          } else if (this.lastStatus <= 0x9f) {\n            eventJson.name = 'Note on';\n            eventJson.channel = this.lastStatus - 0x90 + 1;\n            this.pointer += deltaByteCount + 2;\n          } else if (this.lastStatus <= 0xaf) {\n            // Polyphonic Key Pressure\n            eventJson.name = 'Polyphonic Key Pressure';\n            eventJson.channel = this.lastStatus - 0xa0 + 1;\n            eventJson.note = Constants.NOTES[this.data[eventStartIndex + 1]];\n            eventJson.pressure = event[1];\n            this.pointer += deltaByteCount + 2;\n          } else if (this.lastStatus <= 0xbf) {\n            // Controller Change\n            eventJson.name = 'Controller Change';\n            eventJson.channel = this.lastStatus - 0xb0 + 1;\n            eventJson.number = this.data[eventStartIndex + 1];\n            eventJson.value = this.data[eventStartIndex + 2];\n            this.pointer += deltaByteCount + 2;\n          } else if (this.lastStatus <= 0xcf) {\n            // Program Change\n            eventJson.name = 'Program Change';\n            eventJson.channel = this.lastStatus - 0xc0 + 1;\n            eventJson.value = this.data[eventStartIndex + 1];\n            this.pointer += deltaByteCount + 1;\n          } else if (this.lastStatus <= 0xdf) {\n            // Channel Key Pressure\n            eventJson.name = 'Channel Key Pressure';\n            eventJson.channel = this.lastStatus - 0xd0 + 1;\n            this.pointer += deltaByteCount + 1;\n          } else if (this.lastStatus <= 0xef) {\n            // Pitch Bend\n            eventJson.name = 'Pitch Bend';\n            eventJson.channel = this.lastStatus - 0xe0 + 1;\n            eventJson.value = this.data[eventStartIndex + 2];\n            this.pointer += deltaByteCount + 2;\n          } else {\n            throw \"Unknown event (running): \".concat(this.lastStatus);\n          }\n        } else {\n          this.lastStatus = this.data[eventStartIndex];\n\n          if (this.data[eventStartIndex] <= 0x8f) {\n            // Note off\n            eventJson.name = 'Note off';\n            eventJson.channel = this.lastStatus - 0x80 + 1;\n            eventJson.noteNumber = this.data[eventStartIndex + 1];\n            eventJson.noteName = Constants.NOTES[this.data[eventStartIndex + 1]];\n            eventJson.velocity = Math.round(this.data[eventStartIndex + 2] / 127 * 100);\n            this.pointer += deltaByteCount + 3;\n          } else if (this.data[eventStartIndex] <= 0x9f) {\n            // Note on\n            eventJson.name = 'Note on';\n            eventJson.channel = this.lastStatus - 0x90 + 1;\n            eventJson.noteNumber = this.data[eventStartIndex + 1];\n            eventJson.noteName = Constants.NOTES[this.data[eventStartIndex + 1]];\n            eventJson.velocity = Math.round(this.data[eventStartIndex + 2] / 127 * 100);\n            this.pointer += deltaByteCount + 3;\n          } else if (this.data[eventStartIndex] <= 0xaf) {\n            // Polyphonic Key Pressure\n            eventJson.name = 'Polyphonic Key Pressure';\n            eventJson.channel = this.lastStatus - 0xa0 + 1;\n            eventJson.note = Constants.NOTES[this.data[eventStartIndex + 1]];\n            eventJson.pressure = event[2];\n            this.pointer += deltaByteCount + 3;\n          } else if (this.data[eventStartIndex] <= 0xbf) {\n            // Controller Change\n            eventJson.name = 'Controller Change';\n            eventJson.channel = this.lastStatus - 0xb0 + 1;\n            eventJson.number = this.data[eventStartIndex + 1];\n            eventJson.value = this.data[eventStartIndex + 2];\n            this.pointer += deltaByteCount + 3;\n          } else if (this.data[eventStartIndex] <= 0xcf) {\n            // Program Change\n            eventJson.name = 'Program Change';\n            eventJson.channel = this.lastStatus - 0xc0 + 1;\n            eventJson.value = this.data[eventStartIndex + 1];\n            this.pointer += deltaByteCount + 2;\n          } else if (this.data[eventStartIndex] <= 0xdf) {\n            // Channel Key Pressure\n            eventJson.name = 'Channel Key Pressure';\n            eventJson.channel = this.lastStatus - 0xd0 + 1;\n            this.pointer += deltaByteCount + 2;\n          } else if (this.data[eventStartIndex] <= 0xef) {\n            // Pitch Bend\n            eventJson.name = 'Pitch Bend';\n            eventJson.channel = this.lastStatus - 0xe0 + 1;\n            this.pointer += deltaByteCount + 3;\n          } else {\n            throw \"Unknown event: \".concat(this.data[eventStartIndex]); //eventJson.name = `Unknown.  Pointer: ${this.pointer.toString()}, ${eventStartIndex.toString()}, ${this.data[eventStartIndex]}, ${this.data.length}`;\n          }\n        }\n      }\n\n      this.delta += eventJson.delta;\n      this.events.push(eventJson);\n      return eventJson;\n    }\n    /**\n     * Returns true if pointer has reached the end of the track.\n     * @param {boolean}\n     */\n\n  }, {\n    key: \"endOfTrack\",\n    value: function endOfTrack() {\n      if (this.data[this.pointer + 1] == 0xff && this.data[this.pointer + 2] == 0x2f && this.data[this.pointer + 3] == 0x00) {\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return Track;\n}();\n\nif (!Uint8Array.prototype.forEach) {\n  Object.defineProperty(Uint8Array.prototype, 'forEach', {\n    value: Array.prototype.forEach\n  });\n}\n/**\n * Main player class.  Contains methods to load files, start, stop.\n * @param {function} - Callback to fire for each MIDI event.  Can also be added with on('midiEvent', fn)\n * @param {array} - Array buffer of MIDI file (optional).\n */\n\n\nvar Player = /*#__PURE__*/function () {\n  function Player(eventHandler, buffer) {\n    _classCallCheck(this, Player);\n\n    this.sampleRate = 5; // milliseconds\n\n    this.startTime = 0;\n    this.buffer = buffer || null;\n    this.midiChunksByteLength = null;\n    this.division;\n    this.format;\n    this.setIntervalId = false;\n    this.tracks = [];\n    this.instruments = [];\n    this.defaultTempo = 120;\n    this.tempo = null;\n    this.startTick = 0;\n    this.tick = 0;\n    this.lastTick = null;\n    this.inLoop = false;\n    this.totalTicks = 0;\n    this.events = [];\n    this.totalEvents = 0;\n    this.eventListeners = {};\n    if (typeof eventHandler === 'function') this.on('midiEvent', eventHandler);\n  }\n  /**\n   * Load a file into the player (Node.js only).\n   * @param {string} path - Path of file.\n   * @return {Player}\n   */\n\n\n  _createClass(Player, [{\n    key: \"loadFile\",\n    value: function loadFile(path) {\n      {\n        throw 'loadFile is only supported on Node.js';\n      }\n    }\n    /**\n     * Load an array buffer into the player.\n     * @param {array} arrayBuffer - Array buffer of file to be loaded.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"loadArrayBuffer\",\n    value: function loadArrayBuffer(arrayBuffer) {\n      this.buffer = new Uint8Array(arrayBuffer);\n      return this.fileLoaded();\n    }\n    /**\n     * Load a data URI into the player.\n     * @param {string} dataUri - Data URI to be loaded.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"loadDataUri\",\n    value: function loadDataUri(dataUri) {\n      // convert base64 to raw binary data held in a string.\n      // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this\n      var byteString = Utils.atob(dataUri.split(',')[1]); // write the bytes of the string to an ArrayBuffer\n\n      var ia = new Uint8Array(byteString.length);\n\n      for (var i = 0; i < byteString.length; i++) {\n        ia[i] = byteString.charCodeAt(i);\n      }\n\n      this.buffer = ia;\n      return this.fileLoaded();\n    }\n    /**\n     * Get filesize of loaded file in number of bytes.\n     * @return {number} - The filesize.\n     */\n\n  }, {\n    key: \"getFilesize\",\n    value: function getFilesize() {\n      return this.buffer ? this.buffer.length : 0;\n    }\n    /**\n     * Sets default tempo, parses file for necessary information, and does a dry run to calculate total length.\n     * Populates this.events & this.totalTicks.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"fileLoaded\",\n    value: function fileLoaded() {\n      if (!this.validate()) throw 'Invalid MIDI file; should start with MThd';\n      return this.setTempo(this.defaultTempo).getDivision().getFormat().getTracks().dryRun();\n    }\n    /**\n     * Validates file using simple means - first four bytes should == MThd.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      //console.log((this.buffer.subarray(0, 15)));\n      return Utils.bytesToLetters(this.buffer.subarray(0, 4)) === 'MThd';\n    }\n    /**\n     * Gets MIDI file format for loaded file.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"getFormat\",\n    value: function getFormat() {\n      /*\n      MIDI files come in 3 variations:\n      Format 0 which contain a single track\n      Format 1 which contain one or more simultaneous tracks\n      (ie all tracks are to be played simultaneously).\n      Format 2 which contain one or more independant tracks\n      (ie each track is to be played independantly of the others).\n      return Utils.bytesToNumber(this.buffer.subarray(8, 10));\n      */\n      this.format = Utils.bytesToNumber(this.buffer.subarray(8, 10));\n      return this;\n    }\n    /**\n     * Parses out tracks, places them in this.tracks and initializes this.pointers\n     * @return {Player}\n     */\n\n  }, {\n    key: \"getTracks\",\n    value: function getTracks() {\n      this.tracks = [];\n      var trackOffset = 0;\n\n      while (trackOffset < this.buffer.length) {\n        if (Utils.bytesToLetters(this.buffer.subarray(trackOffset, trackOffset + 4)) == 'MTrk') {\n          var trackLength = Utils.bytesToNumber(this.buffer.subarray(trackOffset + 4, trackOffset + 8));\n          this.tracks.push(new Track(this.tracks.length, this.buffer.subarray(trackOffset + 8, trackOffset + 8 + trackLength)));\n        }\n\n        trackOffset += Utils.bytesToNumber(this.buffer.subarray(trackOffset + 4, trackOffset + 8)) + 8;\n      } // Get sum of all MIDI chunks here while we're at it\n\n\n      var trackChunksByteLength = 0;\n      this.tracks.forEach(function (track) {\n        trackChunksByteLength += 8 + track.data.length;\n      });\n      this.midiChunksByteLength = Constants.HEADER_CHUNK_LENGTH + trackChunksByteLength;\n      return this;\n    }\n    /**\n     * Enables a track for playing.\n     * @param {number} trackNumber - Track number\n     * @return {Player}\n     */\n\n  }, {\n    key: \"enableTrack\",\n    value: function enableTrack(trackNumber) {\n      this.tracks[trackNumber - 1].enable();\n      return this;\n    }\n    /**\n     * Disables a track for playing.\n     * @param {number} - Track number\n     * @return {Player}\n     */\n\n  }, {\n    key: \"disableTrack\",\n    value: function disableTrack(trackNumber) {\n      this.tracks[trackNumber - 1].disable();\n      return this;\n    }\n    /**\n     * Gets quarter note division of loaded MIDI file.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"getDivision\",\n    value: function getDivision() {\n      this.division = Utils.bytesToNumber(this.buffer.subarray(12, Constants.HEADER_CHUNK_LENGTH));\n      return this;\n    }\n    /**\n     * The main play loop.\n     * @param {boolean} - Indicates whether or not this is being called simply for parsing purposes.  Disregards timing if so.\n     * @return {undefined}\n     */\n\n  }, {\n    key: \"playLoop\",\n    value: function playLoop(dryRun) {\n      if (!this.inLoop) {\n        this.inLoop = true;\n        this.tick = this.getCurrentTick();\n        this.tracks.forEach(function (track, index) {\n          // Handle next event\n          if (!dryRun && this.endOfFile()) {\n            //console.log('end of file')\n            this.triggerPlayerEvent('endOfFile');\n            this.stop();\n          } else {\n            var event = track.handleEvent(this.tick, dryRun);\n\n            if (dryRun && event) {\n              if (event.hasOwnProperty('name') && event.name === 'Set Tempo') {\n                // Grab tempo if available.\n                this.defaultTempo = event.data;\n                this.setTempo(event.data);\n              }\n\n              if (event.hasOwnProperty('name') && event.name === 'Program Change') {\n                if (!this.instruments.includes(event.value)) {\n                  this.instruments.push(event.value);\n                }\n              }\n            } else if (event) {\n              if (event.hasOwnProperty('name') && event.name === 'Set Tempo') {\n                // Grab tempo if available.\n                this.setTempo(event.data);\n\n                if (this.isPlaying()) {\n                  this.pause().play();\n                }\n              }\n\n              this.emitEvent(event);\n            }\n          }\n        }, this);\n        if (!dryRun) this.triggerPlayerEvent('playing', {\n          tick: this.tick\n        });\n        this.inLoop = false;\n      }\n    }\n    /**\n     * Setter for tempo.\n     * @param {number} - Tempo in bpm (defaults to 120)\n     */\n\n  }, {\n    key: \"setTempo\",\n    value: function setTempo(tempo) {\n      this.tempo = tempo;\n      return this;\n    }\n    /**\n     * Setter for startTime.\n     * @param {number} - UTC timestamp\n     * @return {Player}\n     */\n\n  }, {\n    key: \"setStartTime\",\n    value: function setStartTime(startTime) {\n      this.startTime = startTime;\n      return this;\n    }\n    /**\n     * Start playing loaded MIDI file if not already playing.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this.isPlaying()) throw 'Already playing...'; // Initialize\n\n      if (!this.startTime) this.startTime = new Date().getTime(); // Start play loop\n      //window.requestAnimationFrame(this.playLoop.bind(this));\n\n      this.setIntervalId = setInterval(this.playLoop.bind(this), this.sampleRate); //this.setIntervalId = this.loop();\n\n      return this;\n    }\n  }, {\n    key: \"loop\",\n    value: function loop() {\n      setTimeout(function () {\n        // Do Something Here\n        this.playLoop(); // Then recall the parent function to\n        // create a recursive loop.\n\n        this.loop();\n      }.bind(this), this.sampleRate);\n    }\n    /**\n     * Pauses playback if playing.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      clearInterval(this.setIntervalId);\n      this.setIntervalId = false;\n      this.startTick = this.tick;\n      this.startTime = 0;\n      return this;\n    }\n    /**\n     * Stops playback if playing.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      clearInterval(this.setIntervalId);\n      this.setIntervalId = false;\n      this.startTick = 0;\n      this.startTime = 0;\n      this.resetTracks();\n      return this;\n    }\n    /**\n     * Skips player pointer to specified tick.\n     * @param {number} - Tick to skip to.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"skipToTick\",\n    value: function skipToTick(tick) {\n      this.stop();\n      this.startTick = tick; // Need to set track event indexes to the nearest possible event to the specified tick.\n\n      this.tracks.forEach(function (track) {\n        track.setEventIndexByTick(tick);\n      });\n      return this;\n    }\n    /**\n     * Skips player pointer to specified percentage.\n     * @param {number} - Percent value in integer format.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"skipToPercent\",\n    value: function skipToPercent(percent) {\n      if (percent < 0 || percent > 100) throw \"Percent must be number between 1 and 100.\";\n      this.skipToTick(Math.round(percent / 100 * this.totalTicks));\n      return this;\n    }\n    /**\n     * Skips player pointer to specified seconds.\n     * @param {number} - Seconds to skip to.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"skipToSeconds\",\n    value: function skipToSeconds(seconds) {\n      var songTime = this.getSongTime();\n      if (seconds < 0 || seconds > songTime) throw seconds + \" seconds not within song time of \" + songTime;\n      this.skipToPercent(seconds / songTime * 100);\n      return this;\n    }\n    /**\n     * Checks if player is playing\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isPlaying\",\n    value: function isPlaying() {\n      return this.setIntervalId > 0 || _typeof(this.setIntervalId) === 'object';\n    }\n    /**\n     * Plays the loaded MIDI file without regard for timing and saves events in this.events.  Essentially used as a parser.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"dryRun\",\n    value: function dryRun() {\n      // Reset tracks first\n      this.resetTracks();\n\n      while (!this.endOfFile()) {\n        this.playLoop(true); //console.log(this.bytesProcessed(), this.midiChunksByteLength);\n      }\n\n      this.events = this.getEvents();\n      this.totalEvents = this.getTotalEvents();\n      this.totalTicks = this.getTotalTicks();\n      this.startTick = 0;\n      this.startTime = 0; // Leave tracks in pristine condish\n\n      this.resetTracks(); //console.log('Song time: ' + this.getSongTime() + ' seconds / ' + this.totalTicks + ' ticks.');\n\n      this.triggerPlayerEvent('fileLoaded', this);\n      return this;\n    }\n    /**\n     * Resets play pointers for all tracks.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"resetTracks\",\n    value: function resetTracks() {\n      this.tracks.forEach(function (track) {\n        return track.reset();\n      });\n      return this;\n    }\n    /**\n     * Gets an array of events grouped by track.\n     * @return {array}\n     */\n\n  }, {\n    key: \"getEvents\",\n    value: function getEvents() {\n      return this.tracks.map(function (track) {\n        return track.events;\n      });\n    }\n    /**\n     * Gets total number of ticks in the loaded MIDI file.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getTotalTicks\",\n    value: function getTotalTicks() {\n      return Math.max.apply(null, this.tracks.map(function (track) {\n        return track.delta;\n      }));\n    }\n    /**\n     * Gets total number of events in the loaded MIDI file.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getTotalEvents\",\n    value: function getTotalEvents() {\n      return this.tracks.reduce(function (a, b) {\n        return {\n          events: {\n            length: a.events.length + b.events.length\n          }\n        };\n      }, {\n        events: {\n          length: 0\n        }\n      }).events.length;\n    }\n    /**\n     * Gets song duration in seconds.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getSongTime\",\n    value: function getSongTime() {\n      return this.totalTicks / this.division / this.tempo * 60;\n    }\n    /**\n     * Gets remaining number of seconds in playback.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getSongTimeRemaining\",\n    value: function getSongTimeRemaining() {\n      return Math.round((this.totalTicks - this.getCurrentTick()) / this.division / this.tempo * 60);\n    }\n    /**\n     * Gets remaining percent of playback.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getSongPercentRemaining\",\n    value: function getSongPercentRemaining() {\n      return Math.round(this.getSongTimeRemaining() / this.getSongTime() * 100);\n    }\n    /**\n     * Number of bytes processed in the loaded MIDI file.\n     * @return {number}\n     */\n\n  }, {\n    key: \"bytesProcessed\",\n    value: function bytesProcessed() {\n      return Constants.HEADER_CHUNK_LENGTH + this.tracks.length * 8 + this.tracks.reduce(function (a, b) {\n        return {\n          pointer: a.pointer + b.pointer\n        };\n      }, {\n        pointer: 0\n      }).pointer;\n    }\n    /**\n     * Number of events played up to this point.\n     * @return {number}\n     */\n\n  }, {\n    key: \"eventsPlayed\",\n    value: function eventsPlayed() {\n      return this.tracks.reduce(function (a, b) {\n        return {\n          eventIndex: a.eventIndex + b.eventIndex\n        };\n      }, {\n        eventIndex: 0\n      }).eventIndex;\n    }\n    /**\n     * Determines if the player pointer has reached the end of the loaded MIDI file.\n     * Used in two ways:\n     * 1. If playing result is based on loaded JSON events.\n     * 2. If parsing (dryRun) it's based on the actual buffer length vs bytes processed.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"endOfFile\",\n    value: function endOfFile() {\n      if (this.isPlaying()) {\n        return this.totalTicks - this.tick <= 0;\n      }\n\n      return this.bytesProcessed() >= this.midiChunksByteLength; //this.buffer.length;\n    }\n    /**\n     * Gets the current tick number in playback.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getCurrentTick\",\n    value: function getCurrentTick() {\n      if (!this.startTime) return this.startTick;\n      return Math.round((new Date().getTime() - this.startTime) / 1000 * (this.division * (this.tempo / 60))) + this.startTick;\n    }\n    /**\n     * Sends MIDI event out to listener.\n     * @param {object}\n     * @return {Player}\n     */\n\n  }, {\n    key: \"emitEvent\",\n    value: function emitEvent(event) {\n      this.triggerPlayerEvent('midiEvent', event);\n      return this;\n    }\n    /**\n     * Subscribes events to listeners\n     * @param {string} - Name of event to subscribe to.\n     * @param {function} - Callback to fire when event is broadcast.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(playerEvent, fn) {\n      if (!this.eventListeners.hasOwnProperty(playerEvent)) this.eventListeners[playerEvent] = [];\n      this.eventListeners[playerEvent].push(fn);\n      return this;\n    }\n    /**\n     * Broadcasts event to trigger subscribed callbacks.\n     * @param {string} - Name of event.\n     * @param {object} - Data to be passed to subscriber callback.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"triggerPlayerEvent\",\n    value: function triggerPlayerEvent(playerEvent, data) {\n      if (this.eventListeners.hasOwnProperty(playerEvent)) this.eventListeners[playerEvent].forEach(function (fn) {\n        return fn(data || {});\n      });\n      return this;\n    }\n  }]);\n\n  return Player;\n}();\n\nvar index = {\n  Player: Player,\n  Utils: Utils,\n  Constants: Constants\n};\n\n\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./node_modules/midi-player-js/build/index.browser.js?");

/***/ }),

/***/ "./src/conversion/MIDIConverter.ts":
/*!*****************************************!*\
  !*** ./src/conversion/MIDIConverter.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.MIDIConverter = void 0;\r\nconst midiPlayerImport = __webpack_require__(/*! midi-player-js */ \"./node_modules/midi-player-js/build/index.browser.js\");\r\nlet midiPlayer = midiPlayerImport.default;\r\n/**\r\n * Convert MIDI file to playable map\r\n */\r\nvar MIDIConverter;\r\n(function (MIDIConverter) {\r\n    function convertFromRaw(info, raw) {\r\n        let map = {\r\n            ...info,\r\n            notes: []\r\n        };\r\n        let player = new midiPlayer.Player(() => { });\r\n        player.loadArrayBuffer(raw);\r\n        let events = player.getEvents();\r\n        // Stage 1\r\n        let midiNotes = [];\r\n        let tempo = 30;\r\n        let minNoteDelta = -1;\r\n        const ticksPerBeat = player.division;\r\n        events.forEach(track => {\r\n            let totalTicks = 0;\r\n            let lastNoteTick = 0;\r\n            for (let i = 0; i < track.length; i++) {\r\n                const event = track[i];\r\n                // @ts-ignore\r\n                const delta = event.delta;\r\n                totalTicks += delta;\r\n                if (event.name == \"Set Tempo\" && event.data > tempo)\r\n                    tempo = event.data;\r\n                if (event.name == \"Note on\") {\r\n                    const lastNoteDelta = totalTicks - lastNoteTick;\r\n                    if (lastNoteDelta > 0) {\r\n                        lastNoteTick = totalTicks;\r\n                        if (minNoteDelta == -1 || minNoteDelta > lastNoteDelta)\r\n                            minNoteDelta = lastNoteDelta;\r\n                    }\r\n                    midiNotes.push({\r\n                        tick: totalTicks,\r\n                        index: event.noteNumber\r\n                    });\r\n                }\r\n            }\r\n        });\r\n        if (minNoteDelta == -1)\r\n            minNoteDelta = ticksPerBeat / 4;\r\n        const notesPerBeat = ticksPerBeat / minNoteDelta;\r\n        console.log(tempo, notesPerBeat, midiNotes);\r\n        // Stage 2: Map them\r\n        midiNotes.forEach(midi => {\r\n            const lane = midi.index % 4;\r\n            const offset = Math.floor(midi.tick / minNoteDelta);\r\n            let note = map.notes.find(v => v.index == lane && v.offset == offset);\r\n            if (!note) {\r\n                note = {\r\n                    index: lane,\r\n                    offset,\r\n                    midiIndexes: [midi.index],\r\n                    duration: 1\r\n                };\r\n                map.notes.push(note);\r\n            }\r\n            else\r\n                note.midiIndexes.push(midi.index);\r\n        });\r\n        map.initialSpeed = tempo * notesPerBeat / 60;\r\n        return map;\r\n    }\r\n    MIDIConverter.convertFromRaw = convertFromRaw;\r\n})(MIDIConverter = exports.MIDIConverter || (exports.MIDIConverter = {}));\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/conversion/MIDIConverter.ts?");

/***/ }),

/***/ "./src/engine/GameMap.ts":
/*!*******************************!*\
  !*** ./src/engine/GameMap.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.TEST_MAP = void 0;\r\nexports.TEST_MAP = {\r\n    title: \"Test Map\",\r\n    author: \"nahkd123\",\r\n    initialSpeed: 1.6,\r\n    scrollAcceleration: 0.02,\r\n    notes: [\r\n        { offset: 0, index: 0, duration: 2, midiIndexes: [] },\r\n        { offset: 0, index: 2, duration: 2, midiIndexes: [] },\r\n        { offset: 2, index: 1, duration: 2, midiIndexes: [] },\r\n        { offset: 2, index: 3, duration: 2, midiIndexes: [] },\r\n        { offset: 4, index: 0, midiIndexes: [] },\r\n        { offset: 5, index: 1, midiIndexes: [] },\r\n        { offset: 6, index: 2, midiIndexes: [] },\r\n        { offset: 7, index: 3, midiIndexes: [] },\r\n        { offset: 8, index: 2, midiIndexes: [] },\r\n        { offset: 9, index: 1, midiIndexes: [] },\r\n        { offset: 10, index: 0, midiIndexes: [] },\r\n        { offset: 11, index: 2, midiIndexes: [] },\r\n        { offset: 12, index: 1, midiIndexes: [] },\r\n        { offset: 13, index: 3, midiIndexes: [] },\r\n        { offset: 14, index: 0, midiIndexes: [] },\r\n        { offset: 15, index: 1, midiIndexes: [] },\r\n        { offset: 16, index: 3, midiIndexes: [] },\r\n        { offset: 17, index: 2, midiIndexes: [] },\r\n        { offset: 18, index: 1, midiIndexes: [] },\r\n        { offset: 19, index: 2, midiIndexes: [] },\r\n        { offset: 20, index: 1, midiIndexes: [] },\r\n        { offset: 21, index: 0, midiIndexes: [] },\r\n        { offset: 21, index: 2, midiIndexes: [] },\r\n        { offset: 22, index: 1, midiIndexes: [] },\r\n        { offset: 22, index: 3, midiIndexes: [] },\r\n        { offset: 23, index: 0, midiIndexes: [] },\r\n        { offset: 23, index: 2, midiIndexes: [] },\r\n        { offset: 24, index: 1, midiIndexes: [] },\r\n        { offset: 24, index: 3, midiIndexes: [] },\r\n        { offset: 25, index: 0, midiIndexes: [] },\r\n        { offset: 25, index: 2, midiIndexes: [] },\r\n        { offset: 26, index: 1, midiIndexes: [] },\r\n        { offset: 26, index: 3, midiIndexes: [] },\r\n        { offset: 27, index: 0, midiIndexes: [] },\r\n        { offset: 27, index: 2, midiIndexes: [] },\r\n        { offset: 28, index: 1, midiIndexes: [] },\r\n        { offset: 28, index: 3, midiIndexes: [] },\r\n    ]\r\n};\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/engine/GameMap.ts?");

/***/ }),

/***/ "./src/engine/MapStore.ts":
/*!********************************!*\
  !*** ./src/engine/MapStore.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.SimpleMapStore = exports.MapStore = void 0;\r\nconst GameMap_1 = __webpack_require__(/*! ./GameMap */ \"./src/engine/GameMap.ts\");\r\nclass MapStore {\r\n}\r\nexports.MapStore = MapStore;\r\nclass SimpleMapStore extends MapStore {\r\n    maps = [\r\n        { ...GameMap_1.TEST_MAP, id: \"0\" }\r\n    ];\r\n    async queryMaps(info) {\r\n        const title = info.title ?? \"\";\r\n        const author = info.author ?? \"\";\r\n        return this.maps.filter(v => v.title.includes(title) && v.author.includes(author));\r\n    }\r\n    async getMap(info) { return this.maps.find(v => v.id == info.id); }\r\n    async putMap(map) {\r\n        const prevIdx = this.maps.findIndex(v => v.id == map.id);\r\n        if (prevIdx != -1)\r\n            this.maps.splice(prevIdx, 1, map);\r\n        else\r\n            this.maps.push(map);\r\n        return true;\r\n    }\r\n}\r\nexports.SimpleMapStore = SimpleMapStore;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/engine/MapStore.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst MapStore_1 = __webpack_require__(/*! ./engine/MapStore */ \"./src/engine/MapStore.ts\");\r\nconst HomeScreen_1 = __webpack_require__(/*! ./ui/screens/HomeScreen */ \"./src/ui/screens/HomeScreen.ts\");\r\nconst BackButton_1 = __webpack_require__(/*! ./ui/BackButton */ \"./src/ui/BackButton.ts\");\r\ndocument.body.append(BackButton_1.BACK_BUTTON.element);\r\nlet mapStore = new MapStore_1.SimpleMapStore();\r\nlet screen = new HomeScreen_1.HomeScreen(mapStore);\r\nscreen.push();\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/index.ts?");

/***/ }),

/***/ "./src/ui/BackButton.ts":
/*!******************************!*\
  !*** ./src/ui/BackButton.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BACK_BUTTON = exports.BackButton = void 0;\r\nconst Screen_1 = __webpack_require__(/*! ./Screen */ \"./src/ui/Screen.ts\");\r\nclass BackButton {\r\n    element;\r\n    constructor() {\r\n        this.element = document.createElement(\"div\");\r\n        this.element.className = \"backbutton invisible\";\r\n        this.element.textContent = \"< Back\";\r\n        this.element.addEventListener(\"click\", () => {\r\n            Screen_1.Screen.pop();\r\n            if (Screen_1.Screen.getStack().length <= 1)\r\n                this.hide();\r\n        });\r\n    }\r\n    show() {\r\n        this.element.classList.add(\"invisibleFinal\");\r\n        this.element.classList.remove(\"invisible\");\r\n        setTimeout(() => this.element.classList.remove(\"invisibleFinal\"));\r\n    }\r\n    hide() {\r\n        this.element.classList.add(\"invisibleFinal\");\r\n        setTimeout(() => {\r\n            this.element.classList.remove(\"invisibleFinal\");\r\n            this.element.classList.add(\"invisible\");\r\n        }, 200);\r\n    }\r\n}\r\nexports.BackButton = BackButton;\r\nexports.BACK_BUTTON = new BackButton();\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/BackButton.ts?");

/***/ }),

/***/ "./src/ui/Playfield.ts":
/*!*****************************!*\
  !*** ./src/ui/Playfield.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Playfield = void 0;\r\nconst Skin_1 = __webpack_require__(/*! ./Skin */ \"./src/ui/Skin.ts\");\r\n/**\r\n * A simple playfield. It can also be used as editor (if you wish)\r\n */\r\nclass Playfield {\r\n    map;\r\n    options;\r\n    container;\r\n    scoreDisplay;\r\n    speedDisplay;\r\n    canvas;\r\n    ctx;\r\n    skin = new Skin_1.DefaultSkin();\r\n    canvasScale = 1;\r\n    notes = [];\r\n    lastNote;\r\n    holdNotes = [];\r\n    hitAnimations = [];\r\n    score = 0;\r\n    time = 0;\r\n    scrollPosition = 0;\r\n    nextNote = 0;\r\n    isStarted = false;\r\n    debugIndex = -1;\r\n    debugOffset = 0;\r\n    failed = false;\r\n    failedIndex = -1;\r\n    failedOffset = -1;\r\n    failedTime = -1;\r\n    failedCallback;\r\n    constructor(map, options = {}) {\r\n        this.map = map;\r\n        this.options = options;\r\n        this.options = {\r\n            initialSpeed: map.initialSpeed,\r\n            scrollAcceleration: map.scrollAcceleration,\r\n            judgementLine: false,\r\n            lanes: 4,\r\n            ...options\r\n        };\r\n        this.notes = [...map.notes];\r\n        this.lastNote = this.notes[this.notes.length - 1];\r\n        this.scrollPosition = this.scrollPositionAtTime(0);\r\n        this.container = document.createElement(\"div\");\r\n        this.container.className = \"container playfield\";\r\n        this.canvas = document.createElement(\"canvas\");\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n        this.canvasScale = devicePixelRatio;\r\n        this.scoreDisplay = document.createElement(\"div\");\r\n        this.scoreDisplay.className = \"display score\";\r\n        this.scoreDisplay.textContent = `${this.score}`;\r\n        this.speedDisplay = document.createElement(\"div\");\r\n        this.speedDisplay.className = \"display speed\";\r\n        this.speedDisplay.textContent = `${this.speedAtTimeDisplay(this.time)} n/s`;\r\n        this.container.append(this.canvas, this.scoreDisplay, this.speedDisplay);\r\n        let observer = new ResizeObserver(() => { this.renderCanvas(); });\r\n        observer.observe(this.canvas);\r\n        this.canvas.addEventListener(\"pointerup\", event => {\r\n            const holdIdx = this.holdNotes.findIndex(v => v.pointerId == event.pointerId);\r\n            if (holdIdx == -1)\r\n                return;\r\n            const width = this.canvas.width;\r\n            const height = this.canvas.height;\r\n            const noteWidth = width / this.options.lanes;\r\n            const noteBaseHeight = noteWidth * 1.75;\r\n            const hold = this.holdNotes[holdIdx];\r\n            const note = hold.note;\r\n            const noteDuration = Math.max(note.duration || 1, 1);\r\n            const noteY = height - (note.offset + noteDuration - this.scrollPosition) * noteBaseHeight;\r\n            const pointerCHeight = Math.floor(hold.pointerY * this.canvasScale);\r\n            const prog = 1 - (pointerCHeight - noteY) / (noteBaseHeight * noteDuration);\r\n            this.hitAnimations.push({\r\n                note: hold.note,\r\n                timestamp: -1,\r\n                holdProgress: prog\r\n            });\r\n            this.score += Math.floor((noteDuration - 1) * (prog + 0.5)); // TODO: add based on prog\r\n            this.scoreDisplay.textContent = `${this.score}`;\r\n            this.holdNotes.splice(holdIdx, 1);\r\n        });\r\n        this.canvas.addEventListener(\"pointerdown\", event => {\r\n            if (this.failed)\r\n                return;\r\n            const width = this.canvas.offsetWidth;\r\n            const height = this.canvas.offsetHeight;\r\n            const noteWidth = width / this.options.lanes;\r\n            const noteHeight = noteWidth * 1.75;\r\n            const noteIndex = Math.floor(event.offsetX / noteWidth);\r\n            const noteOffset = (height - event.offsetY) / noteHeight + this.scrollPosition;\r\n            this.debugIndex = noteIndex;\r\n            this.debugOffset = noteOffset;\r\n            const note = this.noteAt(noteOffset, noteIndex);\r\n            if (note != -1) {\r\n                const prevNote = this.notes[note - 1];\r\n                if (prevNote && prevNote.offset < this.notes[note].offset) {\r\n                    this.failed = true;\r\n                    this.failedIndex = noteIndex;\r\n                    this.failedOffset = Math.floor(noteOffset);\r\n                }\r\n                else {\r\n                    this.score++;\r\n                    this.scoreDisplay.textContent = `${this.score}`;\r\n                    if (Math.max(this.notes[note].duration || 1, 1) == 1) {\r\n                        this.hitAnimations.push({\r\n                            note: this.notes[note],\r\n                            timestamp: -1\r\n                        });\r\n                    }\r\n                    else {\r\n                        this.holdNotes.push({\r\n                            note: this.notes[note],\r\n                            pointerId: event.pointerId,\r\n                            pointerY: event.offsetY\r\n                        });\r\n                    }\r\n                }\r\n                this.notes.splice(note, 1);\r\n                this.applyLoop();\r\n            }\r\n            else {\r\n                this.failed = true;\r\n                this.failedIndex = noteIndex;\r\n                this.failedOffset = Math.floor(noteOffset);\r\n            }\r\n            if (!this.isStarted)\r\n                this.start();\r\n        });\r\n    }\r\n    renderCanvas() {\r\n        const ctx = this.ctx;\r\n        if (this.canvas.width != Math.floor(this.canvas.offsetWidth * this.canvasScale) ||\r\n            this.canvas.height != Math.floor(this.canvas.offsetHeight * this.canvasScale)) {\r\n            this.canvas.width = Math.floor(this.canvas.offsetWidth * this.canvasScale);\r\n            this.canvas.height = Math.floor(this.canvas.offsetHeight * this.canvasScale);\r\n        }\r\n        const width = this.canvas.width;\r\n        const height = this.canvas.height;\r\n        const noteWidth = width / this.options.lanes;\r\n        const noteBaseHeight = noteWidth * 1.75;\r\n        const renderScale = noteWidth / 100;\r\n        ctx.clearRect(0, 0, width, height);\r\n        ctx.scale(width / 100, height / 100);\r\n        this.skin.drawBackground(ctx);\r\n        ctx.scale(100 / width, 100 / height);\r\n        // Bar lines\r\n        const visibleNotes = Math.floor(height / noteBaseHeight) + 1;\r\n        const topOffset = 1 - (this.scrollPosition % 1);\r\n        for (let i = 0; i < visibleNotes; i++) {\r\n            ctx.translate(0, height - (topOffset + i) * noteBaseHeight);\r\n            ctx.scale(width / 100, height / 100);\r\n            this.skin.drawBarLine(ctx);\r\n            ctx.scale(100 / width, 100 / height);\r\n            ctx.translate(0, -(height - (topOffset + i) * noteBaseHeight));\r\n        }\r\n        // Lanes\r\n        for (let i = 0; i < 4; i++) {\r\n            ctx.translate(noteWidth * i, 0);\r\n            ctx.scale(width / 100, height / 100);\r\n            this.skin.drawLaneSeperator(ctx);\r\n            ctx.scale(100 / width, 100 / height);\r\n            ctx.translate(-(noteWidth * i), 0);\r\n        }\r\n        for (let i = 0; i < this.notes.length; i++) {\r\n            if (this.nextNote > i)\r\n                continue;\r\n            const note = this.notes[i];\r\n            const noteDuration = Math.max(note.duration || 1, 1);\r\n            const noteX = noteWidth * note.index;\r\n            const noteY = height - (note.offset + noteDuration - this.scrollPosition) * noteBaseHeight;\r\n            if (noteY > height) {\r\n                this.failed = true;\r\n                this.failedIndex = note.index;\r\n                this.failedOffset = note.offset;\r\n            }\r\n            if (noteY + noteBaseHeight * noteDuration < 0)\r\n                break;\r\n            ctx.translate(noteX, noteY);\r\n            ctx.scale(renderScale, renderScale);\r\n            this.skin.drawNote(ctx, noteDuration, 0.0);\r\n            ctx.scale(1 / renderScale, 1 / renderScale);\r\n            ctx.translate(-noteX, -noteY);\r\n        }\r\n        this.holdNotes.forEach(hold => {\r\n            const note = hold.note;\r\n            const noteDuration = Math.max(note.duration || 1, 1);\r\n            const noteX = noteWidth * note.index;\r\n            const noteY = height - (note.offset + noteDuration - this.scrollPosition) * noteBaseHeight;\r\n            ctx.translate(noteX, noteY);\r\n            ctx.scale(renderScale, renderScale);\r\n            const pointerCHeight = Math.floor(hold.pointerY * this.canvasScale);\r\n            const prog = 1 - (pointerCHeight - noteY) / (noteBaseHeight * noteDuration);\r\n            this.skin.drawNote(ctx, noteDuration, prog);\r\n            ctx.scale(1 / renderScale, 1 / renderScale);\r\n            ctx.translate(-noteX, -noteY);\r\n        });\r\n        ctx.resetTransform();\r\n    }\r\n    scrollPositionAtTime(t) {\r\n        return this.options.initialSpeed * t + (this.options.scrollAcceleration * (t ** 2)) / 2 - 1;\r\n    }\r\n    speedAtTimeDisplay(t) {\r\n        const val = this.options.initialSpeed + this.options.scrollAcceleration * t;\r\n        return val.toFixed(1);\r\n    }\r\n    noteAt(offset, lane) {\r\n        return this.notes.findIndex(v => {\r\n            if (v.index != lane)\r\n                return;\r\n            const offsetEnd = v.offset + (v.duration || 1);\r\n            return offset >= v.offset && offset < offsetEnd;\r\n        });\r\n    }\r\n    start() {\r\n        let beginTimestamp = -1;\r\n        let render = (ts) => {\r\n            if (beginTimestamp == -1) {\r\n                beginTimestamp = ts;\r\n                window.requestAnimationFrame(render);\r\n                return;\r\n            }\r\n            const ctx = this.ctx;\r\n            const width = this.canvas.width;\r\n            const height = this.canvas.height;\r\n            const noteWidth = width / this.options.lanes;\r\n            const noteHeight = noteWidth * 1.75;\r\n            const renderScale = noteWidth / 100;\r\n            this.renderCanvas();\r\n            if (!this.failed) {\r\n                this.time = (ts - beginTimestamp) / 1000;\r\n                this.scrollPosition = this.scrollPositionAtTime(this.time);\r\n                this.speedDisplay.textContent = `${this.speedAtTimeDisplay(this.time)} n/s`;\r\n            }\r\n            else {\r\n                if (this.failedTime == -1)\r\n                    this.failedTime = ts;\r\n                const failedDuration = ts - this.failedTime;\r\n                const failAlpha = failedDuration < 200 ? failedDuration / 200 : 1;\r\n                const targetScroll = Math.floor(this.failedOffset - 1);\r\n                this.scrollPosition = failedDuration < 500 ? this.scrollPosition * 0.8 + targetScroll * 0.2 : targetScroll;\r\n                ctx.fillStyle = `hsla(0, 100%, ${50 + Math.abs(Math.sin(failedDuration / 200) * 30)}%, ${failAlpha})`;\r\n                ctx.fillRect(this.failedIndex * noteWidth, height - (this.failedOffset + 1 - this.scrollPosition) * noteHeight, noteWidth, noteHeight);\r\n                if (failedDuration > 1800) {\r\n                    if (this.failedCallback)\r\n                        this.failedCallback();\r\n                    return;\r\n                }\r\n            }\r\n            this.hitAnimations.forEach(hit => {\r\n                if (hit.timestamp == -1)\r\n                    hit.timestamp = ts;\r\n                const noteTime = ts - hit.timestamp;\r\n                const noteScale = Math.sqrt(noteTime / 200) * Math.min(this.score / 200, 0.6);\r\n                const noteScaleAdd = 1 + noteScale;\r\n                const noteDuration = Math.max(hit.note.duration || 1, 1);\r\n                const noteX = noteWidth * hit.note.index - noteWidth / 2 * noteScale;\r\n                const noteY = height - (hit.note.offset + noteDuration - this.scrollPosition) * noteHeight - noteHeight / 2 * noteScale;\r\n                ctx.translate(noteX, noteY);\r\n                ctx.scale(renderScale * noteScaleAdd, renderScale * noteScaleAdd);\r\n                ctx.globalAlpha = Math.max(1.0 - noteTime / 200, 0.0);\r\n                this.skin.drawNote(ctx, noteDuration, hit.holdProgress ?? 0.0);\r\n                ctx.globalAlpha = 1.0;\r\n                ctx.scale(1 / (renderScale * noteScaleAdd), 1 / (renderScale * noteScaleAdd));\r\n                ctx.translate(-noteX, -noteY);\r\n            });\r\n            this.hitAnimations.filter(v => (ts - v.timestamp) >= 200).forEach(hit => {\r\n                this.hitAnimations.splice(this.hitAnimations.indexOf(hit), 1);\r\n            });\r\n            window.requestAnimationFrame(render);\r\n        };\r\n        window.requestAnimationFrame(render);\r\n        this.isStarted = true;\r\n    }\r\n    applyLoop() {\r\n        if (this.notes.length > 0)\r\n            return;\r\n        const lastNoteEnd = this.lastNote.offset + Math.max(this.lastNote.duration || 1, 1);\r\n        this.map.notes.forEach(note => {\r\n            this.notes.push({\r\n                ...note,\r\n                offset: lastNoteEnd + 8 + note.offset\r\n            });\r\n        });\r\n        this.lastNote = this.notes[this.notes.length - 1];\r\n    }\r\n}\r\nexports.Playfield = Playfield;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/Playfield.ts?");

/***/ }),

/***/ "./src/ui/Screen.ts":
/*!**************************!*\
  !*** ./src/ui/Screen.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Screen = void 0;\r\nconst SCREENS_STACK = [];\r\nclass Screen {\r\n    parent;\r\n    contents;\r\n    constructor() {\r\n        this.parent = document.createElement(\"div\");\r\n        this.parent.className = \"screen pop\";\r\n        this.contents = document.createElement(\"div\");\r\n        this.parent.appendChild(this.contents);\r\n    }\r\n    screenPushAnimation() { this.parent.classList.remove(\"pop\"); }\r\n    screenPopAnimation() { this.parent.classList.add(\"pop\"); }\r\n    push() {\r\n        document.body.appendChild(this.parent);\r\n        SCREENS_STACK.push(this);\r\n        setTimeout(() => this.screenPushAnimation());\r\n    }\r\n    static pop() {\r\n        let screen = SCREENS_STACK.pop();\r\n        screen.screenPopAnimation();\r\n        setTimeout(() => screen.parent.remove(), 200);\r\n        return screen;\r\n    }\r\n    static getStack() { return SCREENS_STACK; }\r\n}\r\nexports.Screen = Screen;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/Screen.ts?");

/***/ }),

/***/ "./src/ui/Skin.ts":
/*!************************!*\
  !*** ./src/ui/Skin.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DefaultSkin = exports.Skin = void 0;\r\n/**\r\n * Skinning. There're some stuffs that I want to point out:\r\n * - The note ratio is always 1:1.75 (Width:Height)\r\n * - All drawing operations starts from 0:0 (unless you call resetTransform)\r\n * - Instead of regular pixels, we use points (pt). Eg: drawNote has 100x175pt\r\n */\r\nclass Skin {\r\n    /**\r\n     * Draw note with ``width = 100pt`` and ``height = length * 175pt``\r\n     * @param ctx The canvas context\r\n     * @param length Note length. The length in pt is 175 * length\r\n     * @param holdProgress Hold progress from 0.0 (not holding) to 1.0.\r\n     */\r\n    drawNote(ctx, length, holdProgress) {\r\n        if (length == 1) {\r\n            ctx.fillStyle = \"black\";\r\n            ctx.fillRect(0, 0, 100, 175 * length);\r\n        }\r\n        else {\r\n            let gradient = ctx.createLinearGradient(0, 175 * length, 0, 0);\r\n            gradient.addColorStop(0, \"rgba(0,0,0,1)\");\r\n            gradient.addColorStop(1 / (length - 0.5), \"rgba(156,117,83,1)\");\r\n            ctx.fillStyle = gradient;\r\n            ctx.fillRect(0, 0, 100, 175 * length);\r\n            ctx.strokeStyle = \"white\";\r\n            ctx.lineWidth = 2;\r\n            ctx.beginPath();\r\n            ctx.moveTo(50, 175 * length - 70);\r\n            ctx.arc(50, 175 * length - 50, 20, 3 * Math.PI / 2, 3 * Math.PI / 2 + Math.PI * 2);\r\n            ctx.lineTo(50, 50);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n            if (holdProgress > 0) {\r\n                const holdSegments = holdProgress * length;\r\n                const progPt = Math.max(175 * length * (1 - holdProgress), 50);\r\n                ctx.fillStyle = `hsla(45, 100%, 70%, ${Math.min(holdSegments, 1.0)})`;\r\n                ctx.beginPath();\r\n                ctx.moveTo(0, 175 * length);\r\n                ctx.lineTo(100, 175 * length);\r\n                ctx.lineTo(100, progPt);\r\n                ctx.arc(50, progPt, 50, Math.PI, Math.PI * 2);\r\n                ctx.lineTo(0, progPt);\r\n                ctx.closePath();\r\n                ctx.fill();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Draw the background. The size is limited to 100x100\r\n     * @param ctx The canvas context\r\n     */\r\n    drawBackground(ctx) {\r\n        let gradient = ctx.createLinearGradient(0, 0, 0, 100);\r\n        gradient.addColorStop(0, \"rgba(255,212,212,1)\");\r\n        gradient.addColorStop(1, \"rgba(201,217,255,1)\");\r\n        ctx.fillStyle = gradient;\r\n        ctx.fillRect(0, 0, 100, 100);\r\n    }\r\n    /**\r\n     * Draw the bar line with width = 100pt and center is located at ``y = 0``\r\n     * @param ctx The canvas context\r\n     */\r\n    drawBarLine(ctx) {\r\n        ctx.fillStyle = \"#0000000e\";\r\n        ctx.fillRect(0, -0.1, 100, 0.2);\r\n    }\r\n    /** Draw the lane seperator with height = 100pt and center is located at ``x = 0`` */\r\n    drawLaneSeperator(ctx) {\r\n        ctx.fillStyle = \"#0000000e\";\r\n        ctx.fillRect(-0.1, 0, 0.2, 100);\r\n    }\r\n}\r\nexports.Skin = Skin;\r\nclass DefaultSkin extends Skin {\r\n}\r\nexports.DefaultSkin = DefaultSkin;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/Skin.ts?");

/***/ }),

/***/ "./src/ui/screens/HomeScreen.ts":
/*!**************************************!*\
  !*** ./src/ui/screens/HomeScreen.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.HomeScreen = void 0;\r\nconst MIDIConverter_1 = __webpack_require__(/*! ../../conversion/MIDIConverter */ \"./src/conversion/MIDIConverter.ts\");\r\nconst BackButton_1 = __webpack_require__(/*! ../BackButton */ \"./src/ui/BackButton.ts\");\r\nconst Screen_1 = __webpack_require__(/*! ../Screen */ \"./src/ui/Screen.ts\");\r\nconst MapInfoScreen_1 = __webpack_require__(/*! ./MapInfoScreen */ \"./src/ui/screens/MapInfoScreen.ts\");\r\nclass HomeScreen extends Screen_1.Screen {\r\n    store;\r\n    listingView;\r\n    uploadMIDIButton;\r\n    constructor(store) {\r\n        super();\r\n        this.store = store;\r\n        this.listingView = document.createElement(\"div\");\r\n        this.listingView.className = \"listing\";\r\n        this.uploadMIDIButton = document.createElement(\"div\");\r\n        this.uploadMIDIButton.className = \"button upload\";\r\n        this.uploadMIDIButton.textContent = \"Upload MIDI\";\r\n        this.contents.append(this.listingView, this.uploadMIDIButton);\r\n        this.applyQuery();\r\n        this.uploadMIDIButton.addEventListener(\"click\", async () => {\r\n            let inp = document.createElement(\"input\");\r\n            inp.type = \"file\";\r\n            inp.click();\r\n            let files = await new Promise(resolve => { inp.onchange = () => { resolve(inp.files); }; });\r\n            for (let i = 0; i < files.length; i++) {\r\n                const file = files.item(i);\r\n                const info = {\r\n                    title: file.name,\r\n                    author: \"Autoconverter (MIDI)\",\r\n                    initialSpeed: 1.8,\r\n                    scrollAcceleration: 0.01,\r\n                    id: file.name + \"-\" + Math.random()\r\n                };\r\n                const map = MIDIConverter_1.MIDIConverter.convertFromRaw(info, await file.arrayBuffer());\r\n                console.log(map);\r\n                await this.store.putMap(map);\r\n                await this.applyQuery();\r\n            }\r\n        });\r\n    }\r\n    async applyQuery(query = {}) {\r\n        while (this.listingView.firstChild)\r\n            this.listingView.firstChild.remove();\r\n        let maps = await this.store.queryMaps(query);\r\n        maps.forEach(mapInfo => {\r\n            let inf = document.createElement(\"div\");\r\n            inf.className = \"metadata mini\";\r\n            let titleView = document.createElement(\"div\");\r\n            titleView.className = \"title\";\r\n            titleView.textContent = mapInfo.title;\r\n            let mapperView = document.createElement(\"div\");\r\n            mapperView.className = \"mapper\";\r\n            mapperView.textContent = `Mapped by ${mapInfo.author}`;\r\n            inf.append(titleView, mapperView);\r\n            this.listingView.append(inf);\r\n            inf.addEventListener(\"click\", async () => {\r\n                const map = await this.store.getMap(mapInfo);\r\n                if (!map)\r\n                    return;\r\n                let screen = new MapInfoScreen_1.MapInfoScreen(map);\r\n                screen.push();\r\n                BackButton_1.BACK_BUTTON.show();\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.HomeScreen = HomeScreen;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/screens/HomeScreen.ts?");

/***/ }),

/***/ "./src/ui/screens/MapInfoScreen.ts":
/*!*****************************************!*\
  !*** ./src/ui/screens/MapInfoScreen.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.MapInfoScreen = void 0;\r\nconst BackButton_1 = __webpack_require__(/*! ../BackButton */ \"./src/ui/BackButton.ts\");\r\nconst Screen_1 = __webpack_require__(/*! ../Screen */ \"./src/ui/Screen.ts\");\r\nconst PlayfieldScreen_1 = __webpack_require__(/*! ./PlayfieldScreen */ \"./src/ui/screens/PlayfieldScreen.ts\");\r\nclass MapInfoScreen extends Screen_1.Screen {\r\n    map;\r\n    metadata;\r\n    titleView;\r\n    mapperView;\r\n    diffView;\r\n    speedView;\r\n    playButton;\r\n    constructor(map) {\r\n        super();\r\n        this.map = map;\r\n        this.metadata = document.createElement(\"div\");\r\n        this.metadata.className = \"metadata\";\r\n        this.titleView = document.createElement(\"div\");\r\n        this.titleView.className = \"title\";\r\n        this.titleView.textContent = map.title;\r\n        this.mapperView = document.createElement(\"div\");\r\n        this.mapperView.className = \"mapper\";\r\n        this.mapperView.textContent = `Mapped by ${map.author}`;\r\n        this.metadata.append(this.titleView, this.mapperView);\r\n        this.diffView = document.createElement(\"div\");\r\n        this.diffView.className = \"diff\";\r\n        this.speedView = document.createElement(\"div\");\r\n        this.speedView.className = \"speed\";\r\n        this.speedView.textContent = `${map.initialSpeed.toFixed(1)} n/s +${map.scrollAcceleration.toFixed(2)}/s`;\r\n        this.diffView.appendChild(this.speedView);\r\n        this.playButton = document.createElement(\"div\");\r\n        this.playButton.className = \"button play\";\r\n        this.playButton.textContent = \"Start\";\r\n        this.contents.append(this.metadata, this.playButton, this.diffView);\r\n        this.playButton.addEventListener(\"click\", () => {\r\n            BackButton_1.BACK_BUTTON.hide();\r\n            Screen_1.Screen.pop();\r\n            let playfieldScreen = new PlayfieldScreen_1.PlayfieldScreen(map);\r\n            playfieldScreen.push();\r\n        });\r\n    }\r\n}\r\nexports.MapInfoScreen = MapInfoScreen;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/screens/MapInfoScreen.ts?");

/***/ }),

/***/ "./src/ui/screens/PlayfieldScreen.ts":
/*!*******************************************!*\
  !*** ./src/ui/screens/PlayfieldScreen.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.PlayfieldScreen = void 0;\r\nconst Playfield_1 = __webpack_require__(/*! ../Playfield */ \"./src/ui/Playfield.ts\");\r\nconst Screen_1 = __webpack_require__(/*! ../Screen */ \"./src/ui/Screen.ts\");\r\nclass PlayfieldScreen extends Screen_1.Screen {\r\n    map;\r\n    playfield;\r\n    constructor(map) {\r\n        super();\r\n        this.map = map;\r\n        this.playfield = new Playfield_1.Playfield(map);\r\n        this.contents.append(this.playfield.container);\r\n        this.playfield.failedCallback = async () => {\r\n            await new Promise(resolve => setTimeout(() => resolve(), 500));\r\n            Screen_1.Screen.pop();\r\n        };\r\n    }\r\n}\r\nexports.PlayfieldScreen = PlayfieldScreen;\r\n\n\n//# sourceURL=webpack://@nahkd123/piano-tiles/./src/ui/screens/PlayfieldScreen.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;